{
    "componentChunkName": "component---src-templates-blog-post-js",
    "path": "/algorithm-towers-hanoi/",
    "result": {"data":{"site":{"siteMetadata":{"title":"jarednielsen.com"}},"markdownRemark":{"id":"d2009127-ca53-541e-ac60-c61fec5bf8ab","excerpt":"If you want to learn how to code, you need to learn algorithms. Learning algorithms improves your problem solving skills by revealing design patterns in…","html":"<p><span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 630px; \"\n    >\n      <a\n    class=\"gatsby-resp-image-link\"\n    href=\"/static/78170f3efa19fd2bcdf2f192601296b5/29007/jarednielsen-algorithm-towers-hanoi.png\"\n    style=\"display: block\"\n    target=\"_blank\"\n    rel=\"noopener\"\n  >\n    <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 56.32911392405063%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAALCAIAAADwazoUAAAACXBIWXMAAAsTAAALEwEAmpwYAAABNUlEQVQoz51Ru0oDQRTdn/GHxGihIEhqwVKsFH9CEHx8glgoNjYWIrHQQi1sZLNJNNlkN9mdmfuYI7tuNhGb4HCYufcM587hTOC9VFAuULcLIKgr9SJQXVCJAsFUqcgIg4lnnY1T1t9eqhbzYiEA7xdnd1srg5d7AFowSs46Z4BqHKDGZqLFVSXWku2Tb7TOl653999uC7En9eJsbp2ZJlLseT5hcbOXBQLI0+nNzvLx9urJwdpR+vAMAB7MRExlKR4KwFqjqlNGAnjhPHvdO2w1NlvrzceNZufyioR63agdhe0o/Oz3HJtJlnZ7nTD8iLrt/uCLxQEaeGVlN2Ybk4nJDMU5CJNN0uEoiUdJnI5HouTIJOnwh0zHiSiVgZW251GbrNdfBlXa5aHFF1VYnAnq6P6Bb0NVdmXN26f7AAAAAElFTkSuQmCC'); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\" Illustration of Towers of Hanoi \"\n        title=\" Illustration of Towers of Hanoi \"\n        src=\"/static/78170f3efa19fd2bcdf2f192601296b5/f058b/jarednielsen-algorithm-towers-hanoi.png\"\n        srcset=\"/static/78170f3efa19fd2bcdf2f192601296b5/c26ae/jarednielsen-algorithm-towers-hanoi.png 158w,\n/static/78170f3efa19fd2bcdf2f192601296b5/6bdcf/jarednielsen-algorithm-towers-hanoi.png 315w,\n/static/78170f3efa19fd2bcdf2f192601296b5/f058b/jarednielsen-algorithm-towers-hanoi.png 630w,\n/static/78170f3efa19fd2bcdf2f192601296b5/40601/jarednielsen-algorithm-towers-hanoi.png 945w,\n/static/78170f3efa19fd2bcdf2f192601296b5/78612/jarednielsen-algorithm-towers-hanoi.png 1260w,\n/static/78170f3efa19fd2bcdf2f192601296b5/29007/jarednielsen-algorithm-towers-hanoi.png 1600w\"\n        sizes=\"(max-width: 630px) 100vw, 630px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n        decoding=\"async\"\n      />\n  </a>\n    </span></p>\n<p>If you want to learn how to code, you need to learn algorithms. Learning algorithms improves your problem solving skills by revealing design patterns in programming. In this tutorial, you will learn how to code the Towers of Hanoi algorithm in JavaScript and Python.</p>\n<hr>\n<p><span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 630px; \"\n    >\n      <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 56.32911392405063%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAALCAYAAAB/Ca1DAAAACXBIWXMAAAsTAAALEwEAmpwYAAABIUlEQVQoz42SPU/DMBCG/YdhZkYwMrKwsjHCxICYkBg6NhkAVZUAUVUtTZU4iWOfH2SHSlGIJSy9yvnu3scfsdput4y12Wzi11qLBEEva2Nu2DOW2u/3TKkoCry1hNHeP9HePcY45EIt5VNaa6ZUlSUiEiG700u+Ty5APOIl1lI+ZYxhSo3WeKCbZRTH5+yOzjAPz3GBptKkfCrsYkqdMRFYX99is1fc8gN9ddMv0nWkfIrEcKGhNXTzF+RzhXv/wszmiK5xXlI2lPeesSLQOXzT4lZr6rcF9WKJXa174O/PmvImgeF54D1t05DnGXmWxRiRvpYCjrc8BIZYnKCrCl3peEchNwT+OXIKGI5clmXU4Ukc5qH2b+C4ceo6UrAA/AFVClZXB07bBgAAAABJRU5ErkJggg=='); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"A is for Algorithms\"\n        title=\"A is for Algorithms\"\n        src=\"/static/9f575ba85d45bde70732b6d52ad2e638/f058b/jarednielsen-algorithms.png\"\n        srcset=\"/static/9f575ba85d45bde70732b6d52ad2e638/c26ae/jarednielsen-algorithms.png 158w,\n/static/9f575ba85d45bde70732b6d52ad2e638/6bdcf/jarednielsen-algorithms.png 315w,\n/static/9f575ba85d45bde70732b6d52ad2e638/f058b/jarednielsen-algorithms.png 630w,\n/static/9f575ba85d45bde70732b6d52ad2e638/40601/jarednielsen-algorithms.png 945w,\n/static/9f575ba85d45bde70732b6d52ad2e638/78612/jarednielsen-algorithms.png 1260w,\n/static/9f575ba85d45bde70732b6d52ad2e638/29114/jarednielsen-algorithms.png 1920w\"\n        sizes=\"(max-width: 630px) 100vw, 630px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n        decoding=\"async\"\n      />\n    </span>\nGive yourself an A. Grab your copy of <a href=\"https://gum.co/algorithms\">A is for Algorithms</a></p>\n<hr>\n<h2>Retrieval Practice</h2>\n<ul>\n<li>\n<p>How does the swap algorithm work?</p>\n</li>\n<li>\n<p>What is recursion?</p>\n</li>\n</ul>\n<h3>How Does the Swap Algorithm Work?</h3>\n<p>The classic swap algorithm uses a temporary variable to <em>stage</em> one of the two values to be swapped while it makes a reassignment.</p>\n<p>If you’re just joining us, you will want to check out <a href=\"https://jarednielsen.com/algorithm-swap/\">How to Code the Swap Algorithm</a></p>\n<h3>What is Recursion?</h3>\n<p>To understand recursion, you must first understand recursion.</p>\n<h2>Let’s Get Meta</h2>\n<ul>\n<li>\n<p>Why do I need to know this?</p>\n</li>\n<li>\n<p>Why is it called the Towers of Hanoi?</p>\n</li>\n</ul>\n<h2>How to Code the Towers of Hanoi Algorithm</h2>\n<p><a href=\"https://jarednielsen.com/programming-problem-solving/\">Programming is problem solving</a>. There are four steps we need to take to solve any programming problem:</p>\n<ol>\n<li>\n<p>Understand the problem</p>\n</li>\n<li>\n<p>Make a plan</p>\n</li>\n<li>\n<p>Execute the plan</p>\n</li>\n<li>\n<p>Evaluate the plan</p>\n</li>\n</ol>\n<h3>Understand the Problem</h3>\n<p>To understand our problem, we first need to define it. Let’s reframe the problem as acceptance criteria:</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">GIVEN a stack of discs in increasing \"size\" and three towers\nWHEN moving the discs from tower one to tower three, larger discs are never stacked on smaller discs\nTHEN I am returned all discs stacked in order on the third tower</code></pre></div>\n<p>That’s our general outline. We know our input conditions (three ‘towers’ and a range of ‘discs’) and our output requirements (the discs stacked largest to smallest on the third tower), and our goal is to move the discs from Tower 1 to Tower 3 without stacking larger discs on smaller discs at any step in the process.</p>\n<p>Let’s make a plan!</p>\n<h3>Make a Plan</h3>\n<p>Let’s revisit our computational thinking heuristics as they will aid and guide is in making a plan. They are:</p>\n<ul>\n<li>\n<p>Decomposition</p>\n</li>\n<li>\n<p>Pattern recognition</p>\n</li>\n<li>\n<p>Abstraction</p>\n</li>\n<li>\n<p>Algorithm design</p>\n</li>\n</ul>\n<h4>Decomposition</h4>\n<p>Let’s break the problem down. What’s the smallest problem we can solve? One disc. We need to move it from Tower 1 to Tower 3. Easy peasy. In a table, this would look like:</p>\n<table>\n<thead>\n<tr>\n<th>Move #</th>\n<th>Tower 1</th>\n<th>Tower 2</th>\n<th>Tower 3</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>0</td>\n<td>1</td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td>1</td>\n<td></td>\n<td></td>\n<td>1</td>\n</tr>\n</tbody>\n</table>\n<p>And in pseudocode, this would look like:</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">INPUT disc count\n\nINIT tower 1 WITH discs EQUAL TO disc count\nINTI tower 2\nINIT tower 3\n\nIF disc count IS EQUAL TO 1\n    MOVE 1 disc FROM tower 1 TO tower 3\n    RETURN tower 3</code></pre></div>\n<p>What if <code class=\"language-text\">disc count</code> is equal to 2?</p>\n<p>We now need to use our second tower to <em>stage</em> the first disc so we can move the second disc to the third tower. If we map this out in a table…</p>\n<table>\n<thead>\n<tr>\n<th>Move #</th>\n<th>Tower 1</th>\n<th>Tower 2</th>\n<th>Tower 3</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>0</td>\n<td>1, 2</td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td>1</td>\n<td>2</td>\n<td>1</td>\n<td></td>\n</tr>\n<tr>\n<td>2</td>\n<td></td>\n<td>1</td>\n<td>2</td>\n</tr>\n<tr>\n<td>3</td>\n<td></td>\n<td></td>\n<td>1, 2</td>\n</tr>\n</tbody>\n</table>\n<p>What if <code class=\"language-text\">disc count</code> is equal to 3?</p>\n<table>\n<thead>\n<tr>\n<th>Move #</th>\n<th>Tower 1</th>\n<th>Tower 2</th>\n<th>Tower 3</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>0</td>\n<td>1, 2, 3</td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td>1</td>\n<td>2, 3</td>\n<td></td>\n<td>1</td>\n</tr>\n<tr>\n<td>2</td>\n<td>3</td>\n<td>2</td>\n<td>1</td>\n</tr>\n<tr>\n<td>3</td>\n<td>3</td>\n<td>1, 2</td>\n<td></td>\n</tr>\n<tr>\n<td>4</td>\n<td></td>\n<td>1, 2</td>\n<td>3</td>\n</tr>\n<tr>\n<td>5</td>\n<td>1</td>\n<td>2</td>\n<td>3</td>\n</tr>\n<tr>\n<td>6</td>\n<td>1</td>\n<td></td>\n<td>2, 3</td>\n</tr>\n<tr>\n<td>7</td>\n<td></td>\n<td></td>\n<td>1, 2, 3</td>\n</tr>\n</tbody>\n</table>\n<p>We can see that as <code class=\"language-text\">disc count</code> increases, the moves required become more complex. Do we see a pattern emerging?</p>\n<p>Let’s do one more…</p>\n<p>What if <code class=\"language-text\">disc count</code> is equal to 4?</p>\n<table>\n<thead>\n<tr>\n<th>Move #</th>\n<th>Tower 1</th>\n<th>Tower 2</th>\n<th>Tower 3</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>0</td>\n<td>1, 2, 3, 4</td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td>1</td>\n<td>2, 3, 4</td>\n<td>1</td>\n<td></td>\n</tr>\n<tr>\n<td>2</td>\n<td>3, 4</td>\n<td>1</td>\n<td>2</td>\n</tr>\n<tr>\n<td>3</td>\n<td>3, 4</td>\n<td></td>\n<td>1, 2</td>\n</tr>\n<tr>\n<td>4</td>\n<td>4</td>\n<td>3</td>\n<td>1, 2</td>\n</tr>\n<tr>\n<td>5</td>\n<td>1, 4</td>\n<td>3</td>\n<td>2</td>\n</tr>\n<tr>\n<td>6</td>\n<td>1, 4</td>\n<td>2, 3</td>\n<td></td>\n</tr>\n<tr>\n<td>7</td>\n<td>4</td>\n<td>1, 2, 3</td>\n<td></td>\n</tr>\n<tr>\n<td>8</td>\n<td></td>\n<td>1, 2, 3</td>\n<td>4</td>\n</tr>\n<tr>\n<td>9</td>\n<td></td>\n<td>2, 3</td>\n<td>1, 4</td>\n</tr>\n<tr>\n<td>10</td>\n<td>2</td>\n<td>3</td>\n<td>1, 4</td>\n</tr>\n<tr>\n<td>11</td>\n<td>1, 2</td>\n<td>3</td>\n<td>4</td>\n</tr>\n<tr>\n<td>12</td>\n<td>1, 2</td>\n<td></td>\n<td>3, 4</td>\n</tr>\n<tr>\n<td>13</td>\n<td>2</td>\n<td>1</td>\n<td>3, 4</td>\n</tr>\n<tr>\n<td>14</td>\n<td></td>\n<td>1</td>\n<td>2, 3, 4</td>\n</tr>\n<tr>\n<td>15</td>\n<td></td>\n<td></td>\n<td>1, 2, 3, 4</td>\n</tr>\n</tbody>\n</table>\n<p>What’s the pattern, or <em>patterns</em> we see?</p>\n<p>Let’s look at The Big Picture first: regardless of the size of <code class=\"language-text\">disc count</code>, the positions of discs required to move from Tower 1 to Tower 3 are mirrored and reversed, with Tower 2 being the pivot at the halfway point. Also note that the number of moves required doubles (approximately) as <code class=\"language-text\">disc count</code> increases.</p>\n<p>Second, if <code class=\"language-text\">disc count</code> is odd, 1 or 3 in the examples above, our first move is from Tower 1 to Tower 3. But, if <code class=\"language-text\">disc count</code> is even, 2 or 4 above, then our first move is from Tower 1 to Tower 2.</p>\n<p>Third, note that the <em>origin</em> of the disc changes move-to-move, but not with <em>every</em> move. For example, as we saw above, where <code class=\"language-text\">disc count</code> is equal to 4, the <em>origin</em> is naturally Tower 1 and we move <code class=\"language-text\">1</code> and <code class=\"language-text\">2</code> to Towers 1 and 2, respectively. On the <em>next</em> move, the <em>origin</em> is Tower 2 as we move <code class=\"language-text\">1</code> to Tower 3. But, on the following move, the <em>origin</em> is again Tower 1. And following that, it’s Tower 3 for two moves!</p>\n<p>Where have we seen this or something like it before?</p>\n<p>Recursion!</p>\n<p>We continually move discs off Tower 1 until we reach our base case, where <code class=\"language-text\">disc count</code> is less than or equal to 1 and then we return those discs to Tower 3. Now we just need to figure out all the steps in between ;).</p>\n<p>Let’s start sketching this out in pseudocode…</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">INPUT disc count\n\nINIT tower 1 WITH discs EQUAL TO disc count\nINTI tower 2\nINIT tower 3\n\nFUNCTION move discs WITH disc count, tower 1, tower 2, tower 3 \n    IF disc count IS EQUAL TO 1\n        MOVE 1 disc FROM tower 1 TO tower 3\n        RETURN tower 3\n\n    CALL move discs WITH disc count MINUS 1, tower 1, tower 2, tower 3\n\n    RETURN tower 3\n\nCALL move discs WITH disc count, tower 1, tower 2, tower 3</code></pre></div>\n<p>Will this work?</p>\n<p>We want our recursive calls to find their way to our base case, so we subtract 1 from <code class=\"language-text\">disc count</code>.</p>\n<p>But what happens if we recursively call our <code class=\"language-text\">move discs</code> function?</p>\n<p>We’ll move all discs from the first tower to the third tower, stacking them in reverse order.</p>\n<p>How do we make recursive calls to our <code class=\"language-text\">move discs</code> function <em>and</em> move the discs to the third tower in order?</p>\n<p>We need to <em>stage</em> discs on our second tower.</p>\n<p>How do we <em>stage</em> discs on our second tower <em>and</em> move them off it?</p>\n<p>Is it a matter of moving the disc to the correct tower? Or moving the tower to the correct disc?</p>\n<p>This is starting to get abstract! So let’s call if what it is…</p>\n<h4>Abstraction</h4>\n<p>With each move, there is an <code class=\"language-text\">origin</code> and a <code class=\"language-text\">goal</code>, and, by necessity, a <code class=\"language-text\">stage</code>. But, with each move, each of these “roles” is performed by a different tower. It might be useful to map this out in a table:</p>\n<table>\n<thead>\n<tr>\n<th>Move #</th>\n<th>Tower 1</th>\n<th>Tower 2</th>\n<th>Tower 3</th>\n<th><code class=\"language-text\">origin</code></th>\n<th><code class=\"language-text\">stage</code></th>\n<th><code class=\"language-text\">goal</code></th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>0</td>\n<td>1, 2</td>\n<td></td>\n<td></td>\n<td></td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td>1</td>\n<td>2</td>\n<td>1</td>\n<td></td>\n<td>Tower 1</td>\n<td></td>\n<td>Tower 2</td>\n</tr>\n<tr>\n<td>2</td>\n<td></td>\n<td>1</td>\n<td>2</td>\n<td>Tower 1</td>\n<td>Tower 2</td>\n<td>Tower 3</td>\n</tr>\n<tr>\n<td>3</td>\n<td></td>\n<td></td>\n<td>1, 2</td>\n<td>Tower 2</td>\n<td></td>\n<td>Tower 3</td>\n</tr>\n</tbody>\n</table>\n<p>Our <em>origin</em> is whichever tower we are moving from and our <em>goal</em> is whichever tower we are moving to. These aren’t necessarily towers one and three, respectively. With each move, nothing happens with the <code class=\"language-text\">stage</code> tower, it’s simply holding the disc(s) from a previous move.</p>\n<p>Let’s see what it looks like when <code class=\"language-text\">disc count</code> is equal to 3:</p>\n<table>\n<thead>\n<tr>\n<th>Move #</th>\n<th>Tower 1</th>\n<th>Tower 2</th>\n<th>Tower 3</th>\n<th><code class=\"language-text\">origin</code></th>\n<th><code class=\"language-text\">stage</code></th>\n<th><code class=\"language-text\">goal</code></th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>0</td>\n<td>1, 2, 3</td>\n<td></td>\n<td></td>\n<td></td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td>1</td>\n<td>2, 3</td>\n<td></td>\n<td>1</td>\n<td>Tower 1</td>\n<td></td>\n<td>Tower 3</td>\n</tr>\n<tr>\n<td>2</td>\n<td>3</td>\n<td>2</td>\n<td>1</td>\n<td>Tower 1</td>\n<td>Tower 3</td>\n<td>Tower 2</td>\n</tr>\n<tr>\n<td>3</td>\n<td>3</td>\n<td>1, 2</td>\n<td></td>\n<td>Tower 3</td>\n<td>Tower 1</td>\n<td>Tower 2</td>\n</tr>\n<tr>\n<td>4</td>\n<td></td>\n<td>1, 2</td>\n<td>3</td>\n<td>Tower 1</td>\n<td>Tower 2</td>\n<td>Tower 3</td>\n</tr>\n<tr>\n<td>5</td>\n<td>1</td>\n<td>2</td>\n<td>3</td>\n<td>Tower 2</td>\n<td>Tower 3</td>\n<td>Tower 1</td>\n</tr>\n<tr>\n<td>6</td>\n<td>1</td>\n<td></td>\n<td>2, 3</td>\n<td>Tower 2</td>\n<td>Tower 1</td>\n<td>Tower 3</td>\n</tr>\n<tr>\n<td>7</td>\n<td></td>\n<td></td>\n<td>1, 2, 3</td>\n<td>Tower 1</td>\n<td></td>\n<td>Tower 3</td>\n</tr>\n</tbody>\n</table>\n<p>How do we translate this to pseudocode?</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">INPUT disc count\n\nINIT tower 1 WITH discs EQUAL TO disc count\nINTI tower 2\nINIT tower 3\n\nFUNCTION move discs WITH disc count, origin, stage, goal PARAMETERS\n    IF disc count IS EQUAL TO 1\n        MOVE 1 disc FROM origin TO goal\n        RETURN goal\n\n    CALL move discs WITH disc count MINUS 1, origin, goal, stage\n\n    MOVE 1 disc FROM origin TO goal\n\n    CALL move discs WITH disc count MINUS 1, stage, origin, goal\n\n    RETURN goal\n\nCALL move discs WITH disc count, tower 1, tower 2, tower 3</code></pre></div>\n<p>What’s happening here?</p>\n<p>We declare a <code class=\"language-text\">move discs</code> function with <code class=\"language-text\">disc count</code>, <code class=\"language-text\">origin</code>, <code class=\"language-text\">stage</code>, and <code class=\"language-text\">goal</code> parameters. When we calal <code class=\"language-text\">move discs</code>, we pass it <code class=\"language-text\">disc count</code>, <code class=\"language-text\">tower 1</code>, <code class=\"language-text\">tower 2</code>, and <code class=\"language-text\">tower 3</code> arguments. Within the <code class=\"language-text\">move discs</code> function is a conditional statement, which returns <code class=\"language-text\">goal</code> when <code class=\"language-text\">disc count</code> is equal to 1. Our <code class=\"language-text\">move discs</code> function then calls itself, but note two things:</p>\n<ol>\n<li>\n<p>We subtract 1 from <code class=\"language-text\">disc count</code></p>\n</li>\n<li>\n<p>We <em>swap</em> the position of the <code class=\"language-text\">goal</code> and <code class=\"language-text\">stage</code> paremeters.</p>\n</li>\n</ol>\n<p>This call to <code class=\"language-text\">move discs</code> will continue to call itself until the conditional is met, where it will return <code class=\"language-text\">goal</code>. On the next line, we move 1 disc from <code class=\"language-text\">origin</code> to <code class=\"language-text\">goal</code>. Our <code class=\"language-text\">move discs</code> function then calls itself <em>again</em>, and again note two thigns:</p>\n<ol>\n<li>\n<p>We subtract 1 from <code class=\"language-text\">disc count</code>. Standard practice with recursion.</p>\n</li>\n<li>\n<p>This time, we <em>swap</em> the position of <code class=\"language-text\">origin</code> and <code class=\"language-text\">stage</code>.</p>\n</li>\n</ol>\n<p>This call to <code class=\"language-text\">move discs</code> will also continue to call itself untile the condition is met, at which point it will return <code class=\"language-text\">goal</code>. When our two recursive calls to <code class=\"language-text\">move discs</code> return and the condition is no longer met, then we return <code class=\"language-text\">goal</code> and exit our initial call to <code class=\"language-text\">move discs</code>.</p>\n<h3>Execute the Plan</h3>\n<p>Now it’s simply a matter of translating our pseudocode into syntax.</p>\n<h4>How to Code the Towers of Hanoi Algorithm in JavaScript</h4>\n<p>Let’s start with JavaScript:</p>\n<div class=\"gatsby-highlight\" data-language=\"js\"><pre class=\"language-js\"><code class=\"language-js\"><span class=\"token keyword\">const</span> <span class=\"token function-variable function\">towers</span> <span class=\"token operator\">=</span> <span class=\"token punctuation\">(</span><span class=\"token parameter\">discCount</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=></span> <span class=\"token punctuation\">{</span>\n\n    <span class=\"token keyword\">const</span> towerOne <span class=\"token operator\">=</span> <span class=\"token punctuation\">[</span><span class=\"token operator\">...</span><span class=\"token function\">Array</span><span class=\"token punctuation\">(</span>discCount <span class=\"token operator\">+</span> <span class=\"token number\">1</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span><span class=\"token function\">keys</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">.</span><span class=\"token function\">slice</span><span class=\"token punctuation\">(</span><span class=\"token number\">1</span><span class=\"token punctuation\">)</span>\n    <span class=\"token keyword\">const</span> towerTwo <span class=\"token operator\">=</span> <span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">,</span> towerThree <span class=\"token operator\">=</span> <span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n\n    <span class=\"token keyword\">const</span> <span class=\"token function-variable function\">moveDiscs</span> <span class=\"token operator\">=</span> <span class=\"token punctuation\">(</span><span class=\"token parameter\">discCount<span class=\"token punctuation\">,</span> origin<span class=\"token punctuation\">,</span> stage<span class=\"token punctuation\">,</span> goal</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=></span> <span class=\"token punctuation\">{</span>\n        <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>discCount <span class=\"token operator\">===</span> <span class=\"token number\">1</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n            <span class=\"token keyword\">let</span> disc <span class=\"token operator\">=</span> origin<span class=\"token punctuation\">.</span><span class=\"token function\">shift</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n            goal<span class=\"token punctuation\">.</span><span class=\"token function\">unshift</span><span class=\"token punctuation\">(</span>disc<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n            <span class=\"token keyword\">return</span> goal<span class=\"token punctuation\">;</span>\n        <span class=\"token punctuation\">}</span>\n\n        <span class=\"token function\">moveDiscs</span><span class=\"token punctuation\">(</span>discCount <span class=\"token operator\">-</span> <span class=\"token number\">1</span><span class=\"token punctuation\">,</span> origin<span class=\"token punctuation\">,</span> goal<span class=\"token punctuation\">,</span> stage<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        \n        <span class=\"token keyword\">let</span> disc <span class=\"token operator\">=</span> origin<span class=\"token punctuation\">.</span><span class=\"token function\">shift</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        goal<span class=\"token punctuation\">.</span><span class=\"token function\">unshift</span><span class=\"token punctuation\">(</span>disc<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n        <span class=\"token function\">moveDiscs</span><span class=\"token punctuation\">(</span>discCount <span class=\"token operator\">-</span> <span class=\"token number\">1</span><span class=\"token punctuation\">,</span> stage<span class=\"token punctuation\">,</span> origin<span class=\"token punctuation\">,</span> goal<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n        <span class=\"token keyword\">return</span> goal<span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n\n    <span class=\"token keyword\">return</span> <span class=\"token function\">moveDiscs</span><span class=\"token punctuation\">(</span>discCount<span class=\"token punctuation\">,</span> towerOne<span class=\"token punctuation\">,</span> towerTwo<span class=\"token punctuation\">,</span> towerThree<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<h4>How to Code the Towers of Hanoi Algorithm in Python</h4>\n<p>Let’s see it in Python:</p>\n<div class=\"gatsby-highlight\" data-language=\"py\"><pre class=\"language-py\"><code class=\"language-py\"><span class=\"token keyword\">def</span> <span class=\"token function\">towers</span><span class=\"token punctuation\">(</span>disc_count<span class=\"token punctuation\">)</span><span class=\"token punctuation\">:</span>\n    tower_one <span class=\"token operator\">=</span> <span class=\"token punctuation\">[</span>i <span class=\"token keyword\">for</span> i <span class=\"token keyword\">in</span> <span class=\"token builtin\">range</span><span class=\"token punctuation\">(</span><span class=\"token number\">1</span><span class=\"token punctuation\">,</span> disc_count <span class=\"token operator\">+</span> <span class=\"token number\">1</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">]</span>\n    tower_two <span class=\"token operator\">=</span> <span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span>\n    tower_three <span class=\"token operator\">=</span> <span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span>\n\n    <span class=\"token keyword\">def</span> <span class=\"token function\">move_discs</span><span class=\"token punctuation\">(</span>disc_count<span class=\"token punctuation\">,</span> origin<span class=\"token punctuation\">,</span> stage<span class=\"token punctuation\">,</span> goal<span class=\"token punctuation\">)</span><span class=\"token punctuation\">:</span>\n        <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>disc_count <span class=\"token operator\">==</span> <span class=\"token number\">1</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">:</span>\n            disc <span class=\"token operator\">=</span> origin<span class=\"token punctuation\">.</span>pop<span class=\"token punctuation\">(</span><span class=\"token number\">0</span><span class=\"token punctuation\">)</span>\n            goal<span class=\"token punctuation\">.</span>insert<span class=\"token punctuation\">(</span><span class=\"token number\">0</span><span class=\"token punctuation\">,</span> disc<span class=\"token punctuation\">)</span>\n\n            <span class=\"token keyword\">return</span> goal\n\n        move_discs<span class=\"token punctuation\">(</span>disc_count <span class=\"token operator\">-</span> <span class=\"token number\">1</span><span class=\"token punctuation\">,</span> origin<span class=\"token punctuation\">,</span> goal<span class=\"token punctuation\">,</span> stage<span class=\"token punctuation\">)</span>\n\n        disc <span class=\"token operator\">=</span> origin<span class=\"token punctuation\">.</span>pop<span class=\"token punctuation\">(</span><span class=\"token number\">0</span><span class=\"token punctuation\">)</span>\n        goal<span class=\"token punctuation\">.</span>insert<span class=\"token punctuation\">(</span><span class=\"token number\">0</span><span class=\"token punctuation\">,</span> disc<span class=\"token punctuation\">)</span>\n\n        move_discs<span class=\"token punctuation\">(</span>disc_count <span class=\"token operator\">-</span> <span class=\"token number\">1</span><span class=\"token punctuation\">,</span> stage<span class=\"token punctuation\">,</span> origin<span class=\"token punctuation\">,</span> goal<span class=\"token punctuation\">)</span>\n\n        <span class=\"token keyword\">return</span> goal\n\n    <span class=\"token keyword\">return</span> move_discs<span class=\"token punctuation\">(</span>disc_count<span class=\"token punctuation\">,</span> tower_one<span class=\"token punctuation\">,</span> tower_two<span class=\"token punctuation\">,</span> tower_three<span class=\"token punctuation\">)</span></code></pre></div>\n<h3>Evaluate the Plan</h3>\n<p>Can we do better?</p>\n<p>How many moves are required for <code class=\"language-text\">n</code> discs?</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">2^n - 1</code></pre></div>\n<p>For 4 discs, we need to make 15 moves.</p>\n<p>But. For 64 discs?</p>\n<p>We would need to make 18,446,744,073,709,551,615 moves!</p>\n<h4>What is the Big O of the Towers of Hanoi Algorithm?</h4>\n<p>If you want to learn how to calculate time and space complexity, pick up your copy of <a href=\"https://gum.co/big-o\">The Little Book of Big O</a></p>\n<h2>Reflection</h2>\n<ul>\n<li>\n<p>Why do I need to know this?</p>\n</li>\n<li>\n<p>Why is it called “The Towers of Hanoi”?</p>\n</li>\n</ul>\n<h3>Why Do I Need to Know This?</h3>\n<p>You don’t! There’s no practical application for this algorithm. It <em>is</em> useful to know for two reasons:</p>\n<ol>\n<li>\n<p><strong>Street Cred</strong>: You can impress your friends with your knowledge of obscure algorithms <em>and</em> there’s always the (slim) chance you’ll get asked to whiteboard it in an interview.</p>\n</li>\n<li>\n<p><strong>Practice Makes Practice</strong>: While you will probably never write this algorithm again, it’s an excellent exercise in computational thinking, highlighting each of the four stages: decomposition, pattern recognition, abstraction, and design Additionally, it demonstrates what a powerful tool recursion is.</p>\n</li>\n</ol>\n<h3>Why is It Called “The Towers of Hanoi”?</h3>\n<p>The algorithm takes its name from its resemblance to a <a href=\"https://en.wikipedia.org/wiki/Pagoda\">pagoda</a>. According to Wikipedia, the problem was first introduced to the West by <a href=\"https://en.wikipedia.org/wiki/%C3%89douard_Lucas\">Edouard Lucas</a>, a French mathematician. He likely used “Hanoi” as the name due to France’s colonization of Vietnam during his lifetime.</p>\n<h2>A is for Algorithms</h2>\n<p><span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 630px; \"\n    >\n      <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 56.32911392405063%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAALCAYAAAB/Ca1DAAAACXBIWXMAAAsTAAALEwEAmpwYAAABIUlEQVQoz42SPU/DMBCG/YdhZkYwMrKwsjHCxICYkBg6NhkAVZUAUVUtTZU4iWOfH2SHSlGIJSy9yvnu3scfsdput4y12Wzi11qLBEEva2Nu2DOW2u/3TKkoCry1hNHeP9HePcY45EIt5VNaa6ZUlSUiEiG700u+Ty5APOIl1lI+ZYxhSo3WeKCbZRTH5+yOzjAPz3GBptKkfCrsYkqdMRFYX99is1fc8gN9ddMv0nWkfIrEcKGhNXTzF+RzhXv/wszmiK5xXlI2lPeesSLQOXzT4lZr6rcF9WKJXa174O/PmvImgeF54D1t05DnGXmWxRiRvpYCjrc8BIZYnKCrCl3peEchNwT+OXIKGI5clmXU4Ukc5qH2b+C4ceo6UrAA/AFVClZXB07bBgAAAABJRU5ErkJggg=='); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"A is for Algorithms\"\n        title=\"A is for Algorithms\"\n        src=\"/static/9f575ba85d45bde70732b6d52ad2e638/f058b/jarednielsen-algorithms.png\"\n        srcset=\"/static/9f575ba85d45bde70732b6d52ad2e638/c26ae/jarednielsen-algorithms.png 158w,\n/static/9f575ba85d45bde70732b6d52ad2e638/6bdcf/jarednielsen-algorithms.png 315w,\n/static/9f575ba85d45bde70732b6d52ad2e638/f058b/jarednielsen-algorithms.png 630w,\n/static/9f575ba85d45bde70732b6d52ad2e638/40601/jarednielsen-algorithms.png 945w,\n/static/9f575ba85d45bde70732b6d52ad2e638/78612/jarednielsen-algorithms.png 1260w,\n/static/9f575ba85d45bde70732b6d52ad2e638/29114/jarednielsen-algorithms.png 1920w\"\n        sizes=\"(max-width: 630px) 100vw, 630px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n        decoding=\"async\"\n      />\n    </span>\nGive yourself an A. Grab your copy of <a href=\"https://gum.co/algorithms\">A is for Algorithms</a></p>","frontmatter":{"title":"Learn How to Code the Towers of Hanoi Algorithm","date":"December 02, 2022","description":"If you want to learn how to code, you need to learn algorithms. Learning algorithms improves your problem solving skills by revealing design patterns in programming. In this tutorial, you will learn how to code the Towers of Hanoi algorithm in JavaScript and Python."}},"previous":{"fields":{"slug":"/algorithm-quick-sort/"},"frontmatter":{"title":"Learn How to Code the Quick Sort Algorithm"}},"next":{"fields":{"slug":"/algorithm-combinations/"},"frontmatter":{"title":"Learn How to Code the Combinations Algorithm"}}},"pageContext":{"id":"d2009127-ca53-541e-ac60-c61fec5bf8ab","previousPostId":"e2159b8b-55b2-5279-89c1-619a2070af72","nextPostId":"29beb888-f3fa-5dae-8627-6220184b9815"}},
    "staticQueryHashes": ["2841359383","3257411868"]}