{"componentChunkName":"component---src-templates-blog-post-js","path":"/big-o-recursive-time-complexity/","result":{"data":{"site":{"siteMetadata":{"title":"jarednielsen.com","author":"Jared Nielsen"}},"markdownRemark":{"id":"37fc3064-aa95-58b1-9be3-c83f1ae66eac","excerpt":"After Big O, the second most terrifying computer science topic might be recursion. Don‚Äôt let the memes scare you, recursion is just recursion. It‚Äôs very easy to‚Ä¶","html":"<p>\n  <a\n    class=\"gatsby-resp-image-link\"\n    href=\"/static/82d91a3fd2072cce2081085db2d9761c/2f950/jarednielsen-big-o-recursive-time-complexity.png\"\n    style=\"display: block\"\n    target=\"_blank\"\n    rel=\"noopener\"\n  >\n  \n  <span\n    class=\"gatsby-resp-image-wrapper\"\n    style=\"position: relative; display: block;  max-width: 590px; margin-left: auto; margin-right: auto;\"\n  >\n    <span\n      class=\"gatsby-resp-image-background-image\"\n      style=\"padding-bottom: 56.25%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAALCAYAAAB/Ca1DAAAACXBIWXMAAAsTAAALEwEAmpwYAAAAw0lEQVQoz62SSwvCMBCE+///jODFg/bixXrSXqpIER+gIFqfYN5jSExb0UgjBoYNu+zHLEyklIJXUr7Wsu/fiXwD99zPQLXKvgwAmgUuINZbA5H7YwmS5ytkcfJC34HCumBJCtLqgg1T0N4AYrWBuhPwLAft9CvXjYGjiQVqMI0T8OlcOy3AxxlIOw4AupN1lZcbFGUQ+bI6eXeAmC3CgNap0Nt6gXMrQqEYN8Jz3txhPTZOn+LUODb1uHxTSA5/1d+BD8kFYp+XSm4LAAAAAElFTkSuQmCC'); background-size: cover; display: block;\"\n    >\n      <img\n        class=\"gatsby-resp-image-image\"\n        style=\"width: 100%; height: 100%; margin: 0; vertical-align: middle; position: absolute; top: 0; left: 0; box-shadow: inset 0px 0px 0px 400px white;\"\n        alt=\"jarednielsen big o recursive time complexity\"\n        title=\"\"\n        src=\"/static/82d91a3fd2072cce2081085db2d9761c/b9e4f/jarednielsen-big-o-recursive-time-complexity.png\"\n        srcset=\"/static/82d91a3fd2072cce2081085db2d9761c/cf440/jarednielsen-big-o-recursive-time-complexity.png 148w,\n/static/82d91a3fd2072cce2081085db2d9761c/d2d38/jarednielsen-big-o-recursive-time-complexity.png 295w,\n/static/82d91a3fd2072cce2081085db2d9761c/b9e4f/jarednielsen-big-o-recursive-time-complexity.png 590w,\n/static/82d91a3fd2072cce2081085db2d9761c/f9b6a/jarednielsen-big-o-recursive-time-complexity.png 885w,\n/static/82d91a3fd2072cce2081085db2d9761c/2d849/jarednielsen-big-o-recursive-time-complexity.png 1180w,\n/static/82d91a3fd2072cce2081085db2d9761c/2f950/jarednielsen-big-o-recursive-time-complexity.png 1600w\"\n        sizes=\"(max-width: 590px) 100vw, 590px\"\n      />\n    </span>\n  </span>\n  \n  </a>\n    </p>\n<p>After Big O, the second most terrifying computer science topic might be recursion. Don‚Äôt let the memes scare you, recursion is just recursion. It‚Äôs very easy to understand and you don‚Äôt need to be a 10X developer to do so. In this tutorial, you‚Äôll learn the fundamentals of calculating Big O recursive time complexity.</p>\n<hr>\n<p>Want to level up your problem solving skills? </p>\n<p>I write a weekly newsletter about programming, problem solving and lifelong learning. </p>\n<p><a href=\"http://eepurl.com/cP8CMn\">Sign up for <em>The Solution</em></a></p>\n<hr>\n<h2>What Problem(s) Does Recursion Solve?</h2>\n<ul>\n<li>Recursion allows us to write functions that are compact and elegant.</li>\n</ul>\n<h3>What Problem(s) Does Recursion Create?</h3>\n<ul>\n<li>Recursion can easily exceed the maximum size of the call stack. </li>\n<li>Recursion can make the program harder to understand not only for your collaborators, but for your future self</li>\n</ul>\n<h2>What is Recursion?</h2>\n<p>In computer science, recursion occurs when a function calls itself within its declaration. </p>\n<p>For example: </p>\n<div class=\"gatsby-highlight\" data-language=\"js\"><pre class=\"language-js\"><code class=\"language-js\"><span class=\"token keyword\">const</span> <span class=\"token function-variable function\">loop</span> <span class=\"token operator\">=</span> <span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=></span> <span class=\"token function\">loop</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></code></pre></div>\n<p>If you run this in your browser console or using Node, you‚Äôll get an error. </p>\n<p>Why? </p>\n<p>Too much recursion!</p>\n<p><code>const loop()</code> is just that, a <em>constant</em> loop.</p>\n<p>üîÅ</p>\n<p>We use recursion to solve a large problem by breaking it down into smaller instances of the same problem.</p>\n<p>To do that, we need to tell our function what the smallest instance looks like. </p>\n<p>If you recall, with <a href=\"https://jarednielsen.com/proof-induction/\">proof by induction</a> we need to establish two things:</p>\n<ol>\n<li>base</li>\n<li>induction</li>\n</ol>\n<p>Recursion is similar. We also need to establish a base case but rather than induction, we establish the <em>recursive case</em>. </p>\n<p>We use the recursive case to break the problem down into smaller instances. </p>\n<p>We use the base case to return when there are no more problems to be solved. </p>\n<p>For example. a family on vacation:</p>\n<div class=\"gatsby-highlight\" data-language=\"js\"><pre class=\"language-js\"><code class=\"language-js\"><span class=\"token keyword\">const</span> <span class=\"token function-variable function\">fighting</span> <span class=\"token operator\">=</span> <span class=\"token parameter\">patience</span> <span class=\"token operator\">=></span> <span class=\"token punctuation\">{</span>\n <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>patience <span class=\"token operator\">&lt;=</span> <span class=\"token number\">0</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n   <span class=\"token keyword\">return</span> <span class=\"token string\">\"If you don‚Äôt stop fighting, I will turn this car around!\"</span>\n <span class=\"token punctuation\">}</span>\n <span class=\"token keyword\">return</span> <span class=\"token function\">fighting</span><span class=\"token punctuation\">(</span>patience <span class=\"token operator\">-</span> <span class=\"token number\">1</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span></code></pre></div>\n<p>The kids are fighting in the backseat. </p>\n<p>Dad is driving and quickly losing his patience. </p>\n<p>Our recursive case is the constant fighting. </p>\n<p>Our base case is dad‚Äôs patience when it runs out.</p>\n<p>üöó </p>\n<h3>Recursion: Factorial</h3>\n<p>The classic example of recursion is computing the factorial of a given number.</p>\n<p>What‚Äôs a <a href=\"https://en.wikipedia.org/wiki/Factorial\">factorial</a>? </p>\n<p>A factorial is the product of all positive integers less than or equal to <em>n</em>. </p>\n<p>We write that as <em>n!</em>. </p>\n<p>For example, 5!:</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">5 * 4 * 3 * 2 * 1 = 120</code></pre></div>\n<p>Here‚Äôs an iterative factorial in JavaScript:</p>\n<div class=\"gatsby-highlight\" data-language=\"js\"><pre class=\"language-js\"><code class=\"language-js\"><span class=\"token keyword\">const</span> <span class=\"token function-variable function\">factorial</span> <span class=\"token operator\">=</span> <span class=\"token parameter\">num</span> <span class=\"token operator\">=></span> <span class=\"token punctuation\">{</span>\n   <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>num <span class=\"token operator\">===</span> <span class=\"token number\">0</span> <span class=\"token operator\">||</span> num <span class=\"token operator\">===</span> <span class=\"token number\">1</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n       <span class=\"token keyword\">return</span> <span class=\"token number\">1</span><span class=\"token punctuation\">;</span>\n   <span class=\"token punctuation\">}</span>\n \n   <span class=\"token keyword\">for</span> <span class=\"token punctuation\">(</span><span class=\"token keyword\">let</span> i <span class=\"token operator\">=</span> num <span class=\"token operator\">-</span> <span class=\"token number\">1</span><span class=\"token punctuation\">;</span> i <span class=\"token operator\">>=</span> <span class=\"token number\">1</span><span class=\"token punctuation\">;</span> i<span class=\"token operator\">--</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n     num <span class=\"token operator\">*=</span> i<span class=\"token punctuation\">;</span>\n   <span class=\"token punctuation\">}</span>\n   <span class=\"token keyword\">return</span> num<span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span></code></pre></div>\n<p>And here it is refactored with recursion:</p>\n<div class=\"gatsby-highlight\" data-language=\"js\"><pre class=\"language-js\"><code class=\"language-js\"><span class=\"token keyword\">const</span> <span class=\"token function-variable function\">factorial</span> <span class=\"token operator\">=</span> <span class=\"token parameter\">num</span> <span class=\"token operator\">=></span> <span class=\"token punctuation\">{</span>\n   <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>num <span class=\"token operator\">==</span> <span class=\"token number\">0</span> <span class=\"token operator\">||</span> num <span class=\"token operator\">===</span> <span class=\"token number\">1</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n       <span class=\"token keyword\">return</span> <span class=\"token number\">1</span><span class=\"token punctuation\">;</span>\n   <span class=\"token punctuation\">}</span> <span class=\"token keyword\">else</span> <span class=\"token punctuation\">{</span>\n       <span class=\"token keyword\">return</span> <span class=\"token punctuation\">(</span>num <span class=\"token operator\">*</span> <span class=\"token function\">factorial</span><span class=\"token punctuation\">(</span>num <span class=\"token operator\">-</span> <span class=\"token number\">1</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n   <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span></code></pre></div>\n<p>Every call to <code>factorial()</code> again calls <code>factorial()</code>, but decreases the value of <code>num</code> by 1, until the base case is met and 1 is returned. </p>\n<h2>Fibonacci</h2>\n<p><a href=\"https://en.wikipedia.org/wiki/Fibonacci_number\">Fibonacci</a> is a sequence of numbers where each number is the sum of the preceding two. </p>\n<p>It starts like this‚Ä¶</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">0 1 1 2 3 5 8 13 21 34 55 89 144‚Ä¶</code></pre></div>\n<p>Fibonacci algorithms are standard challenges for beginners and technical interviews. There are many ways to solve a Fibonacci algorithm and each reveals the depth of your knowledge.</p>\n<p>Let‚Äôs dive in!</p>\n<h3>Iterative Fibonacci</h3>\n<p>Before we get to recursion, let‚Äôs look at an iterative solution to the problem.</p>\n<p>Given an integer, <code>n</code>, calculate the sum of a Fibonacci sequence.</p>\n<div class=\"gatsby-highlight\" data-language=\"js\"><pre class=\"language-js\"><code class=\"language-js\"><span class=\"token keyword\">const</span> <span class=\"token function-variable function\">fiberative</span> <span class=\"token operator\">=</span> <span class=\"token parameter\">n</span> <span class=\"token operator\">=></span> <span class=\"token punctuation\">{</span>\n   <span class=\"token keyword\">let</span> arr <span class=\"token operator\">=</span> <span class=\"token punctuation\">[</span><span class=\"token number\">0</span><span class=\"token punctuation\">,</span> <span class=\"token number\">1</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n   <span class=\"token keyword\">for</span> <span class=\"token punctuation\">(</span><span class=\"token keyword\">let</span> i <span class=\"token operator\">=</span> <span class=\"token number\">2</span><span class=\"token punctuation\">;</span> i <span class=\"token operator\">&lt;</span> n <span class=\"token operator\">+</span> <span class=\"token number\">1</span><span class=\"token punctuation\">;</span> i<span class=\"token operator\">++</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">{</span>\n     arr<span class=\"token punctuation\">.</span><span class=\"token function\">push</span><span class=\"token punctuation\">(</span>arr<span class=\"token punctuation\">[</span>i <span class=\"token operator\">-</span> <span class=\"token number\">2</span><span class=\"token punctuation\">]</span> <span class=\"token operator\">+</span> arr<span class=\"token punctuation\">[</span>i <span class=\"token operator\">-</span><span class=\"token number\">1</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span>\n   <span class=\"token punctuation\">}</span>\n  <span class=\"token keyword\">return</span> arr<span class=\"token punctuation\">[</span>n<span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span></code></pre></div>\n<p>What is the order of <code>fiberative()</code>?</p>\n<p>O(n).</p>\n<p>Why? </p>\n<p>Our solution is <em>iterative</em>. We perform <code>n</code> operations. </p>\n<p>If you want to go deeper, check out <a href=\"https://jarednielsen.com/big-o-linear-time-complexity/\">Big O Linear Time Complexity</a></p>\n<h3>Recursive Fibonacci</h3>\n<p>Now let‚Äôs implement our algorithm using recursion. </p>\n<div class=\"gatsby-highlight\" data-language=\"js\"><pre class=\"language-js\"><code class=\"language-js\"><span class=\"token keyword\">const</span> <span class=\"token function-variable function\">fibonaive</span> <span class=\"token operator\">=</span> <span class=\"token parameter\">n</span> <span class=\"token operator\">=></span> <span class=\"token punctuation\">{</span>\n   <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>n <span class=\"token operator\">&lt;=</span> <span class=\"token number\">0</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n       <span class=\"token keyword\">return</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span>\n   <span class=\"token punctuation\">}</span> <span class=\"token keyword\">else</span> <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>n <span class=\"token operator\">===</span> <span class=\"token number\">1</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n       <span class=\"token keyword\">return</span> <span class=\"token number\">1</span><span class=\"token punctuation\">;</span>\n   <span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span>\n \n   <span class=\"token keyword\">return</span> <span class=\"token function\">fibonaive</span><span class=\"token punctuation\">(</span>n <span class=\"token operator\">-</span> <span class=\"token number\">1</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">+</span> <span class=\"token function\">fibonaive</span><span class=\"token punctuation\">(</span>n <span class=\"token operator\">-</span> <span class=\"token number\">2</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span></code></pre></div>\n<p>What‚Äôs the order of <code>fibonaive()</code>?</p>\n<p>Spoiler: it‚Äôs not good. </p>\n<p>That‚Äôs why this approach is referred to as the <em>naive</em> implementation. </p>\n<p>Let‚Äôs get informed.</p>\n<h2>Calculating Recursive Time Complexity</h2>\n<p>Let‚Äôs make a small adjustment to <code>fibonaive()</code> for the purpose of illustration:</p>\n<div class=\"gatsby-highlight\" data-language=\"js\"><pre class=\"language-js\"><code class=\"language-js\"><span class=\"token keyword\">const</span> <span class=\"token function-variable function\">fibonot</span> <span class=\"token operator\">=</span> <span class=\"token parameter\">n</span> <span class=\"token operator\">=></span> <span class=\"token punctuation\">{</span>\n   <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>n <span class=\"token operator\">&lt;=</span> <span class=\"token number\">0</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n       <span class=\"token keyword\">return</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span>\n   <span class=\"token punctuation\">}</span> <span class=\"token keyword\">else</span> <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>n <span class=\"token operator\">===</span> <span class=\"token number\">1</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n       <span class=\"token keyword\">return</span> <span class=\"token number\">1</span><span class=\"token punctuation\">;</span>\n   <span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span>\n \n   <span class=\"token keyword\">return</span> <span class=\"token function\">fibonot</span><span class=\"token punctuation\">(</span>n <span class=\"token operator\">-</span> <span class=\"token number\">1</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">+</span> <span class=\"token function\">fibonot</span><span class=\"token punctuation\">(</span>n <span class=\"token operator\">-</span> <span class=\"token number\">1</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span></code></pre></div>\n<p>‚òùÔ∏è We only modified the last line so that <code>fibonot()</code> is now balanced. </p>\n<p>What‚Äôs happening in our function?</p>\n<p>Every time we call <code>fibonot()</code>, we call <code>fibonot()</code> twice.</p>\n<p>In each of those calls, we subtract 1 from <code>n</code>.</p>\n<p>How many times does this happen?</p>\n<p><code>n</code> </p>\n<p>We call <code>fibonot()</code> until the value of <code>n</code>  is less than or equal to 0, or equal to 1, then we return without a call.</p>\n<p>Have we seen this, or something like it, before?</p>\n<p>ü§î</p>\n<p>Every invocation of <code>fibonot()</code> creates two <em>branches</em> by calling itself twice. </p>\n<p>Our branches are creating a <em>tree</em>.</p>\n<p>With each iteration, the value of <code>n</code> becomes smaller until one of our <em>base</em> conditions is met. </p>\n<p>So the <em>depth</em>  of our tree is <code>n</code>. </p>\n<p>Let‚Äôs map out the calls:</p>\n<p>\n  <a\n    class=\"gatsby-resp-image-link\"\n    href=\"/static/7d700ad7dfada9204d1c95e942718172/2f950/jarednielsen-big-o-recursion-tree.png\"\n    style=\"display: block\"\n    target=\"_blank\"\n    rel=\"noopener\"\n  >\n  \n  <span\n    class=\"gatsby-resp-image-wrapper\"\n    style=\"position: relative; display: block;  max-width: 590px; margin-left: auto; margin-right: auto;\"\n  >\n    <span\n      class=\"gatsby-resp-image-background-image\"\n      style=\"padding-bottom: 56.25%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAALCAYAAAB/Ca1DAAAACXBIWXMAAAsTAAALEwEAmpwYAAAAtUlEQVQoz82S2wqEMAxE+/+fWsRqvddqlhOILMWyoC8bCNHpzCSkded5yl3+iprO1YyO45B937WO4ygxRsk5X1jN2JVG8zxL13WyrqvmsizXN2fbtikGh1oaOwNMME2TDMOgZMRlgMFlahIN/xY6YUpJvPfa1QLDtm21gU2AGIxqWN/3qqWRTshOmqbR3bAnutIghHAJIJPWEFM4cDlnt3jAcd87KOsT7PaW35i62nt6mv9v+AHyhmSBBEE1JgAAAABJRU5ErkJggg=='); background-size: cover; display: block;\"\n    >\n      <img\n        class=\"gatsby-resp-image-image\"\n        style=\"width: 100%; height: 100%; margin: 0; vertical-align: middle; position: absolute; top: 0; left: 0; box-shadow: inset 0px 0px 0px 400px white;\"\n        alt=\"jarednielsen big o recursion tree\"\n        title=\"\"\n        src=\"/static/7d700ad7dfada9204d1c95e942718172/b9e4f/jarednielsen-big-o-recursion-tree.png\"\n        srcset=\"/static/7d700ad7dfada9204d1c95e942718172/cf440/jarednielsen-big-o-recursion-tree.png 148w,\n/static/7d700ad7dfada9204d1c95e942718172/d2d38/jarednielsen-big-o-recursion-tree.png 295w,\n/static/7d700ad7dfada9204d1c95e942718172/b9e4f/jarednielsen-big-o-recursion-tree.png 590w,\n/static/7d700ad7dfada9204d1c95e942718172/f9b6a/jarednielsen-big-o-recursion-tree.png 885w,\n/static/7d700ad7dfada9204d1c95e942718172/2d849/jarednielsen-big-o-recursion-tree.png 1180w,\n/static/7d700ad7dfada9204d1c95e942718172/2f950/jarednielsen-big-o-recursion-tree.png 1600w\"\n        sizes=\"(max-width: 590px) 100vw, 590px\"\n      />\n    </span>\n  </span>\n  \n  </a>\n    </p>\n<p>Do you see a pattern? </p>\n<p>Where have we seen this, or something like it, before? </p>\n<p>ü§î</p>\n<p><a href=\"https://jarednielsen.com/sum-consecutive-powers-2/\">Powers of 2!</a></p>\n<table>\n<thead>\n<tr>\n<th>Exponent</th>\n<th>Power</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>2^3</td>\n<td>8</td>\n</tr>\n<tr>\n<td>2^2</td>\n<td>4</td>\n</tr>\n<tr>\n<td>2^1</td>\n<td>2</td>\n</tr>\n<tr>\n<td>2^0</td>\n<td>1</td>\n</tr>\n</tbody>\n</table>\n<p>So what‚Äôs the order of <code>fibonot()</code>? </p>\n<p>O(2^n)</p>\n<p>Exponential! </p>\n<p>Ew!</p>\n<p>As a rule of thumb, when calculating recursive runtimes, use the following formula:</p>\n<blockquote>\n<p><em>branches^depth</em></p>\n</blockquote>\n<p>Where branches are the number of recursive calls made in the function definition and depth is the value passed to the first call.</p>\n<p>In the illustration above, there are two branches with a depth of 4. </p>\n<p>Let‚Äôs return to <code>fibonaive()</code>.</p>\n<p>What‚Äôs its Big O? </p>\n<p>For our purposes, it‚Äôs O(2^n).</p>\n<p>Technically, it‚Äôs O(1.6^n). </p>\n<p>Why? </p>\n<p>Let‚Äôs plant a tree! üå≤</p>\n<p>\n  <a\n    class=\"gatsby-resp-image-link\"\n    href=\"/static/a5699072a9b66081806867d7ed53e5dd/2f950/jarednielsen-big-o-recursion-fibonacci-tree.png\"\n    style=\"display: block\"\n    target=\"_blank\"\n    rel=\"noopener\"\n  >\n  \n  <span\n    class=\"gatsby-resp-image-wrapper\"\n    style=\"position: relative; display: block;  max-width: 590px; margin-left: auto; margin-right: auto;\"\n  >\n    <span\n      class=\"gatsby-resp-image-background-image\"\n      style=\"padding-bottom: 56.25%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAALCAYAAAB/Ca1DAAAACXBIWXMAAAsTAAALEwEAmpwYAAAAwklEQVQoz9WS2wrEIAxE/f8frVB6r71qs5yApWhLWfZphWA0MxNHNcdxSBrp8N7Lvu/Z/h3XpELMkNd1lXmeZVkW6fte2rbVNUHt2uBRMIQgzjkpy1LGccxORs4eNTBg4WSCDIpVVSmBAbCu60ywaZoTs22bYuDGkxqSYRjU1jRNag2xruvUHmtsYxMMOSJRNDo7BelqrZWiKLQjawrk8T4hQ4o1xO/uXgUBczLi2vU6py/79MKn5bev8E2YXwX+T/ADB5tk8C2+gZwAAAAASUVORK5CYII='); background-size: cover; display: block;\"\n    >\n      <img\n        class=\"gatsby-resp-image-image\"\n        style=\"width: 100%; height: 100%; margin: 0; vertical-align: middle; position: absolute; top: 0; left: 0; box-shadow: inset 0px 0px 0px 400px white;\"\n        alt=\"jarednielsen big o recursion fibonacci tree\"\n        title=\"\"\n        src=\"/static/a5699072a9b66081806867d7ed53e5dd/b9e4f/jarednielsen-big-o-recursion-fibonacci-tree.png\"\n        srcset=\"/static/a5699072a9b66081806867d7ed53e5dd/cf440/jarednielsen-big-o-recursion-fibonacci-tree.png 148w,\n/static/a5699072a9b66081806867d7ed53e5dd/d2d38/jarednielsen-big-o-recursion-fibonacci-tree.png 295w,\n/static/a5699072a9b66081806867d7ed53e5dd/b9e4f/jarednielsen-big-o-recursion-fibonacci-tree.png 590w,\n/static/a5699072a9b66081806867d7ed53e5dd/f9b6a/jarednielsen-big-o-recursion-fibonacci-tree.png 885w,\n/static/a5699072a9b66081806867d7ed53e5dd/2d849/jarednielsen-big-o-recursion-fibonacci-tree.png 1180w,\n/static/a5699072a9b66081806867d7ed53e5dd/2f950/jarednielsen-big-o-recursion-fibonacci-tree.png 1600w\"\n        sizes=\"(max-width: 590px) 100vw, 590px\"\n      />\n    </span>\n  </span>\n  \n  </a>\n    </p>\n<p>What do you see? </p>\n<p>Unlike <code>fibonot()</code> above, our tree is not balanced. </p>\n<p>How many leaves are there on the tree? </p>\n<p>We <em>could</em> count them by hand, but we‚Äôre problem solvers. </p>\n<h3>Math O‚ÄôClock üßÆüïí</h3>\n<p>Fibonacci is also expressed using the following formula:</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">F(n) = F(n -1) + F(n - 2)</code></pre></div>\n<p>Let‚Äôs use this formula to solve for <code>x</code></p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">x^n = x^(n -1) + x^(n - 2)</code></pre></div>\n<p>We first divide both sides by x^(n - 2)</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">x^2 = x + 1</code></pre></div>\n<p>Subtract 1 from both sides</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">x^2 - 1 = x</code></pre></div>\n<p>Subtract x from both sides </p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">x^2 - 1 - x = 0 </code></pre></div>\n<p>Where have we seen this, or something like it, before? </p>\n<p>ü§î</p>\n<p>It‚Äôs a quadratic equation! </p>\n<p>Quadratic equations follow the form:</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">ax^2 + bx + c = 0</code></pre></div>\n<p>We can use the quadratic formula to solve for x. </p>\n<p>\n  <a\n    class=\"gatsby-resp-image-link\"\n    href=\"/static/dc9e58a94002276906294022f426263e/d40c8/quadratic-formula.png\"\n    style=\"display: block\"\n    target=\"_blank\"\n    rel=\"noopener\"\n  >\n  \n  <span\n    class=\"gatsby-resp-image-wrapper\"\n    style=\"position: relative; display: block;  max-width: 590px; margin-left: auto; margin-right: auto;\"\n  >\n    <span\n      class=\"gatsby-resp-image-background-image\"\n      style=\"padding-bottom: 30.85%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAGCAYAAADDl76dAAAACXBIWXMAAAsSAAALEgHS3X78AAAAjUlEQVQY06XRSwuCQBSG4TGnFAQLy7x1XUctggQ30ab//5d8Jz5lFkVEHzzMMAePx9GY3xPIVKy3/5oIc8SYIMQJNzQocESJXC96ZYFEe6s1xR53cY3OaHFBhjU6PFUb88ASNa4aP9UE7myDSo3cgys1c5NtcVB9zEzr8FmfkmmanfkjgXc31vsR7+qmB+K/BhKwslkiAAAAAElFTkSuQmCC'); background-size: cover; display: block;\"\n    >\n      <img\n        class=\"gatsby-resp-image-image\"\n        style=\"width: 100%; height: 100%; margin: 0; vertical-align: middle; position: absolute; top: 0; left: 0; box-shadow: inset 0px 0px 0px 400px white;\"\n        alt=\"quadratic formula\"\n        title=\"\"\n        src=\"/static/dc9e58a94002276906294022f426263e/b9e4f/quadratic-formula.png\"\n        srcset=\"/static/dc9e58a94002276906294022f426263e/cf440/quadratic-formula.png 148w,\n/static/dc9e58a94002276906294022f426263e/d2d38/quadratic-formula.png 295w,\n/static/dc9e58a94002276906294022f426263e/b9e4f/quadratic-formula.png 590w,\n/static/dc9e58a94002276906294022f426263e/f9b6a/quadratic-formula.png 885w,\n/static/dc9e58a94002276906294022f426263e/2d849/quadratic-formula.png 1180w,\n/static/dc9e58a94002276906294022f426263e/d40c8/quadratic-formula.png 2000w\"\n        sizes=\"(max-width: 590px) 100vw, 590px\"\n      />\n    </span>\n  </span>\n  \n  </a>\n    </p>\n<p>Let‚Äôs plug in our values:</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">- (-1) + sqrt((-1)^2 - 4 * 1 * (-1)) / 2 * 1</code></pre></div>\n<p>First, let‚Äôs simplify the numerator.</p>\n<p>A negative negative is positive, so:</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">1 + sqrt((-1)^2 + 4 * 1 * 1)</code></pre></div>\n<p>A negative integer raised to a power is positive, so:</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">(-1)^2 = 1</code></pre></div>\n<p>Leaving us with the following:</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">1 + sqrt(1 + 4 * 1 * 1)</code></pre></div>\n<p>If we simplify the terms of the numerator:</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">1 + sqrt(5)</code></pre></div>\n<p>And simplify the terms of the denominator:</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">x = (1 + sqrt(5)) / 2</code></pre></div>\n<p>Which is equal to ~1.6.</p>\n<p>AKA œÜ</p>\n<p>AKA <a href=\"https://en.wikipedia.org/wiki/Phi\">Phi</a></p>\n<p>AKA <a href=\"https://en.wikipedia.org/wiki/Fibonacci_number#Binet&#x27;s_formula\">Binet‚Äôs formula</a>.</p>\n<p>AKA <a href=\"https://en.wikipedia.org/wiki/Golden_ratio\">the Golden Ratio</a>. </p>\n<p>‚òùÔ∏è</p>\n<p>‚ÄúHold up there, mister‚Äù, I hear you say. </p>\n<p>‚ÄúWhat about the other half of the quadratic formula?‚Äù</p>\n<p>Good eye! üïµÔ∏è</p>\n<p>You noticed that the quadratic formula results in two solutions, signified by the <a href=\"https://en.wikipedia.org/wiki/Plus%E2%80%93minus_sign\">plus-minus sign</a>.</p>\n<p>Each solution charts the x-intercept of a parabola. </p>\n<p>But we‚Äôre not interested in negative values, so we can stop with one solution.</p>\n<h2>Space Complexity: The Final Frontier üöÄ</h2>\n<p>If the time complexity of our recursive Fibonacci is O(2^n), what‚Äôs the space complexity?</p>\n<p>Tempted to say the same? </p>\n<p>The branching diagram may not be helpful here because your intuition may be to count the function calls themselves.</p>\n<p>Don‚Äôt count the leaves. </p>\n<p>How deep is the tree?</p>\n<p>üìù Space complexity is the amount of memory used by the algorithm. </p>\n<p>When a function is called, it is added to the stack.</p>\n<p>When a function returns, it is popped off the stack.</p>\n<p>We‚Äôre not adding <em>all</em> of the function calls to the stack at once. </p>\n<p>We are only making <code>n</code> calls at any given time as we move up and down branches.\nWe proceed branch by branch, making our function calls until our base case is met, then we return and make our calls down the next branch. </p>\n<p>So the space complexity is O(n).</p>\n<h2>Big O Recursive Time Complexity</h2>\n<p>In this tutorial, you‚Äôll learn the fundamentals of calculating Big O recursive time complexity. If recursive runtimes are so bad, why is everyone so hot for recursion? We‚Äôll answer that in a future article. Stay tuned.</p>","frontmatter":{"title":"Big O Recursive Time Complexity","date":"March 12, 2020","description":"In this tutorial, you‚Äôll learn the fundamentals of calculating Big O recursive time complexity by calculating the sum of a Fibonacci sequence."}}},"pageContext":{"isCreatedByStatefulCreatePages":false,"slug":"/big-o-recursive-time-complexity/","previous":{"fields":{"slug":"/proof-induction/"},"frontmatter":{"title":"Proof By Induction"}},"next":null}}}