{"componentChunkName":"component---src-templates-blog-post-js","path":"/dynamic-programming-memoization-tabulation/","result":{"data":{"site":{"siteMetadata":{"title":"jarednielsen.com","author":"Jared Nielsen"}},"markdownRemark":{"id":"4804ff12-1a99-5d77-be80-659f3ef9e67f","excerpt":"Dynamic programming is a fancy name for something you probably do already: effeciently solving a big problem by breaking it down into smaller problems and…","html":"<p>\n  <a\n    class=\"gatsby-resp-image-link\"\n    href=\"/static/1f712ed61d2706b3733d7307579036aa/2f950/jarednielsen-dynamic-programming-memoization-tabulation.png\"\n    style=\"display: block\"\n    target=\"_blank\"\n    rel=\"noopener\"\n  >\n  \n  <span\n    class=\"gatsby-resp-image-wrapper\"\n    style=\"position: relative; display: block;  max-width: 590px; margin-left: auto; margin-right: auto;\"\n  >\n    <span\n      class=\"gatsby-resp-image-background-image\"\n      style=\"padding-bottom: 56.25%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAALCAYAAAB/Ca1DAAAACXBIWXMAAAsTAAALEwEAmpwYAAACIklEQVQoz4WS3UuTYRjG33+gVIiogznTTTfdsm1vzm3NRTMWwSg6qLOggyIIOokoSZQRgX3hQawvJpuLLWskImYeNBNUsMKoGKNC+sIjES1YZu7j195tzncj6IILHh7u57qv+34ugQIymUyO8nMmnd5gSmKKdIHSXfk7CQJlKIryf+REy4wIJa4KnZNLP+BngtTcd1bic6zEPpF8HWN5OMqH2/2877rG/Nh47l1a5rToUG5ZwsTZDp4Y2onoHYQarEQaHQTrWrilaMar3k2vUMXk6XP54tU1WEvmJ5I7TCV+sTg+zXJ0mujRU3QKFXgqlFzarODCJgXdlTvo3dbIje1NXNmiIqRrI/FolJcnzzPbdTXvNjuhsL5cabTIVh2RSi1hpUi4WmRUvYeA0kRIbWGwrpVIjYhfYcRba6Kzqoan5oOMtB3m1cXLMsGCw/TqH74MjxE9foZggxmfQk9IayGgs+LVtODT2ejXmOmt1jFo2Md1tYEercgz5xE+3w3kNZLJf+9w8W2Mme4ewtYD9NUa8NeL3Glqpc/oyDaw4FUZCZr24lE1M+Rw8/Xx0Iag/JfTyVSJ+O+FReLBAUaOnSCot3Kv3ojPYMe300Zgl52bGpGQzcXCxFReQxq5JMjrLIS3mLdsqOenZpjs8PDQ6cZv20+g1cl9ox2/3cXSm3fFOqE81CW5zH6Y5FqOb89fMNDuJug6lBVu50H2vBz/WAz6X6BFxkqL0usgAAAAAElFTkSuQmCC'); background-size: cover; display: block;\"\n    >\n      <img\n        class=\"gatsby-resp-image-image\"\n        style=\"width: 100%; height: 100%; margin: 0; vertical-align: middle; position: absolute; top: 0; left: 0; box-shadow: inset 0px 0px 0px 400px white;\"\n        alt=\"jarednielsen dynamic programming memoization tabulation\"\n        title=\"\"\n        src=\"/static/1f712ed61d2706b3733d7307579036aa/b9e4f/jarednielsen-dynamic-programming-memoization-tabulation.png\"\n        srcset=\"/static/1f712ed61d2706b3733d7307579036aa/cf440/jarednielsen-dynamic-programming-memoization-tabulation.png 148w,\n/static/1f712ed61d2706b3733d7307579036aa/d2d38/jarednielsen-dynamic-programming-memoization-tabulation.png 295w,\n/static/1f712ed61d2706b3733d7307579036aa/b9e4f/jarednielsen-dynamic-programming-memoization-tabulation.png 590w,\n/static/1f712ed61d2706b3733d7307579036aa/f9b6a/jarednielsen-dynamic-programming-memoization-tabulation.png 885w,\n/static/1f712ed61d2706b3733d7307579036aa/2d849/jarednielsen-dynamic-programming-memoization-tabulation.png 1180w,\n/static/1f712ed61d2706b3733d7307579036aa/2f950/jarednielsen-dynamic-programming-memoization-tabulation.png 1600w\"\n        sizes=\"(max-width: 590px) 100vw, 590px\"\n      />\n    </span>\n  </span>\n  \n  </a>\n    </p>\n<p>Dynamic programming is a fancy name for something you probably do already: effeciently solving a big problem by breaking it down into smaller problems and reusing the solutions to the smaller problems to avoid solving them more than once. In this tutorial, you will learn the fundamentals of the two approaches to dynamic programming: memoization and tabulation.</p>\n<p>This article is part of a series on Big O notation. If you’re just joining us, you may want to read the previous article, <a href=\"https://jarednielsen.com/big-o-recursive-space-complexity/\">Big O Recursive Space Complexity</a>, or start at the beginning with <a href=\"https://jarednielsen.com/big-o-notation/\">What is Big O Notation?</a>.</p>\n<h2>What Problem(s) Does Dynamic Programming Solve?</h2>\n<ul>\n<li>Dynamic programming helps us optimize solutions to problems by caching values for future use</li>\n<li>Dynamic programming helps us improve the runtimes of recursive algorithms</li>\n</ul>\n<h2>Dynamic Programming: Optimal Substructure and Overlapping Subproblems</h2>\n<p>There are two criteria for a dynamic programming approach to problem solving:</p>\n<ul>\n<li>Optimal substructure</li>\n<li>Overlapping subproblems</li>\n</ul>\n<p>What is <em>optimal substructure</em>? </p>\n<p>The solution to a larger problem can be found by combining the returned values of its smaller problems. </p>\n<p>Like recursion and <a href=\"https://jarednielsen.com/proof-induction/\">proof by induction</a>, we recognize a pattern and apply the same approach to solving the parts as we would the whole.</p>\n<p>What are <em>overlapping subproblems</em>?</p>\n<p>The solution to a larger problem recognizes redundancy in the smaller problems and <em>caches</em> those solutions for later recall rather than repeatedly solving the same problem, making the algorithm much more efficient. </p>\n<p>Both of these concepts will click when we refactor our naive sum of Fibonacci sequence algorithm.</p>\n<p>☝️ This might sound a lot like divide and conquer, but divide and conquer algorithms, such as merge sort and quick sort, don’t solve overlapping subproblems. They continually divide a problem into smaller, yet new, problems, then recombine the smaller solutions into a solution to the larger problem.</p>\n<h3>Top-down vs. Bottom-up</h3>\n<p>There are two approaches for implementing a dynamic programming solution:</p>\n<ul>\n<li>Top-down</li>\n<li>Bottom-up</li>\n</ul>\n<p>The top-down approach is generally recursive (but less efficient) and more intuitive to implement as it is often a matter of recognizing the pattern in an algorithm and refactoring it as a dynamic programming solution.</p>\n<p>The bottom-up approach is generally iterative (and more efficient), but less intuitive and requires us to solve (and know!) the smaller problems first then use the combined values of the smaller problems for the larger solution. </p>\n<p>We refer to top-down solutions as <em>memoization</em> and bottom-up as <em>tabulation</em>.</p>\n<p>We’ll look at the reason for these terms below. </p>\n<p>But first, a quick refresher. </p>\n<h2>Fibonacci</h2>\n<p>We’ll revisit our naive recursive sum of Fibonacci sequence for this tutorial. If you’re just joining us, you may want to first read <a href=\"https://jarednielsen.com/big-o-recursive-time-complexity\">Big O Recursive Time Complexity</a>.</p>\n<p>The sum of the Fibonacci sequence is a contrived example, but it is useful (and concise) in illustrating the difference between memoization and tabulation and how to refactor a recursive function for improved time and space complexity. </p>\n<h3>Naive Recursive Fibonacci</h3>\n<p>Here’s our naive implementation of the sum of the Fibonacci sequence. </p>\n<div class=\"gatsby-highlight\" data-language=\"js\"><pre class=\"language-js\"><code class=\"language-js\"><span class=\"token keyword\">const</span> <span class=\"token function-variable function\">fibonaive</span> <span class=\"token operator\">=</span> <span class=\"token parameter\">n</span> <span class=\"token operator\">=></span> <span class=\"token punctuation\">{</span>\n <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>n <span class=\"token operator\">==</span> <span class=\"token number\">0</span> <span class=\"token operator\">||</span> n <span class=\"token operator\">==</span> <span class=\"token number\">1</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n   <span class=\"token keyword\">return</span> n<span class=\"token punctuation\">;</span>\n <span class=\"token punctuation\">}</span>\n \n <span class=\"token keyword\">return</span> <span class=\"token function\">fibonaive</span><span class=\"token punctuation\">(</span>n <span class=\"token operator\">-</span> <span class=\"token number\">1</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">+</span> <span class=\"token function\">fibonaive</span><span class=\"token punctuation\">(</span>n <span class=\"token operator\">-</span> <span class=\"token number\">2</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span></code></pre></div>\n<p>Why is it <em>naive</em>? </p>\n<p>Because the runtime is <em>really</em> bad.</p>\n<p>It’s O(2^n).</p>\n<p>(Actually, it’s O(1.6^n), but who’s counting?)</p>\n<p>Take a look at this diagram of our recursive call branches.</p>\n<p>\n  <a\n    class=\"gatsby-resp-image-link\"\n    href=\"/static/a5699072a9b66081806867d7ed53e5dd/2f950/jarednielsen-big-o-recursion-fibonacci-tree.png\"\n    style=\"display: block\"\n    target=\"_blank\"\n    rel=\"noopener\"\n  >\n  \n  <span\n    class=\"gatsby-resp-image-wrapper\"\n    style=\"position: relative; display: block;  max-width: 590px; margin-left: auto; margin-right: auto;\"\n  >\n    <span\n      class=\"gatsby-resp-image-background-image\"\n      style=\"padding-bottom: 56.25%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAALCAYAAAB/Ca1DAAAACXBIWXMAAAsTAAALEwEAmpwYAAAAwklEQVQoz9WS2wrEIAxE/f8frVB6r71qs5yApWhLWfZphWA0MxNHNcdxSBrp8N7Lvu/Z/h3XpELMkNd1lXmeZVkW6fte2rbVNUHt2uBRMIQgzjkpy1LGccxORs4eNTBg4WSCDIpVVSmBAbCu60ywaZoTs22bYuDGkxqSYRjU1jRNag2xruvUHmtsYxMMOSJRNDo7BelqrZWiKLQjawrk8T4hQ4o1xO/uXgUBczLi2vU6py/79MKn5bev8E2YXwX+T/ADB5tk8C2+gZwAAAAASUVORK5CYII='); background-size: cover; display: block;\"\n    >\n      <img\n        class=\"gatsby-resp-image-image\"\n        style=\"width: 100%; height: 100%; margin: 0; vertical-align: middle; position: absolute; top: 0; left: 0; box-shadow: inset 0px 0px 0px 400px white;\"\n        alt=\"Recursive Fibonacci Tree\"\n        title=\"\"\n        src=\"/static/a5699072a9b66081806867d7ed53e5dd/b9e4f/jarednielsen-big-o-recursion-fibonacci-tree.png\"\n        srcset=\"/static/a5699072a9b66081806867d7ed53e5dd/cf440/jarednielsen-big-o-recursion-fibonacci-tree.png 148w,\n/static/a5699072a9b66081806867d7ed53e5dd/d2d38/jarednielsen-big-o-recursion-fibonacci-tree.png 295w,\n/static/a5699072a9b66081806867d7ed53e5dd/b9e4f/jarednielsen-big-o-recursion-fibonacci-tree.png 590w,\n/static/a5699072a9b66081806867d7ed53e5dd/f9b6a/jarednielsen-big-o-recursion-fibonacci-tree.png 885w,\n/static/a5699072a9b66081806867d7ed53e5dd/2d849/jarednielsen-big-o-recursion-fibonacci-tree.png 1180w,\n/static/a5699072a9b66081806867d7ed53e5dd/2f950/jarednielsen-big-o-recursion-fibonacci-tree.png 1600w\"\n        sizes=\"(max-width: 590px) 100vw, 590px\"\n      />\n    </span>\n  </span>\n  \n  </a>\n    </p>\n<p>Why is this algorithm inefficient? </p>\n<p>Overlapping subproblems! </p>\n<p>We solve the same problems repeatedly in our branches. </p>\n<p>\n  <a\n    class=\"gatsby-resp-image-link\"\n    href=\"/static/368401b370a0ffa4776f67268829919d/a987b/jarednielsen-big-o-recursion-fibonacci-tree-overlapping-subproblems.png\"\n    style=\"display: block\"\n    target=\"_blank\"\n    rel=\"noopener\"\n  >\n  \n  <span\n    class=\"gatsby-resp-image-wrapper\"\n    style=\"position: relative; display: block;  max-width: 590px; margin-left: auto; margin-right: auto;\"\n  >\n    <span\n      class=\"gatsby-resp-image-background-image\"\n      style=\"padding-bottom: 56.25%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAALCAYAAAB/Ca1DAAAACXBIWXMAAAsTAAALEwEAmpwYAAAA+UlEQVQoz9VS7W6DMAzk/V90rdDaQMmX7fhmBwoa6iZN/bVIVhL7fJyPDKqKc5yXiICZv+Uc9ap3OBP57s21VuScUUrBPM8IIfS7B1lNhTda/Eyo2hBjxDiOWOJiyhqEZVfFdvZcshqFD9T0gHQhJ8K+yoR6v0JoJWi2jxOjtGNMMlHjzCBZMUSEGz0QUbvYTuiF+9LwuTBySwia0Kw62Z64gkMEshGDMUkCFYLeFhu5bV4qmk22ExIElzwhXgLUvPO7F0ilg8EG9tHtMwxvtGzlw/ceh4+DGHt2ybmuzZvJO+hp/XbYcy/+8DryE/jLU/hLDO8S/D/CLwZqZl15PczAAAAAAElFTkSuQmCC'); background-size: cover; display: block;\"\n    >\n      <img\n        class=\"gatsby-resp-image-image\"\n        style=\"width: 100%; height: 100%; margin: 0; vertical-align: middle; position: absolute; top: 0; left: 0; box-shadow: inset 0px 0px 0px 400px white;\"\n        alt=\"Recursive Fibonacci Tree Overlapping Subproblems\"\n        title=\"\"\n        src=\"/static/368401b370a0ffa4776f67268829919d/b9e4f/jarednielsen-big-o-recursion-fibonacci-tree-overlapping-subproblems.png\"\n        srcset=\"/static/368401b370a0ffa4776f67268829919d/cf440/jarednielsen-big-o-recursion-fibonacci-tree-overlapping-subproblems.png 148w,\n/static/368401b370a0ffa4776f67268829919d/d2d38/jarednielsen-big-o-recursion-fibonacci-tree-overlapping-subproblems.png 295w,\n/static/368401b370a0ffa4776f67268829919d/b9e4f/jarednielsen-big-o-recursion-fibonacci-tree-overlapping-subproblems.png 590w,\n/static/368401b370a0ffa4776f67268829919d/f9b6a/jarednielsen-big-o-recursion-fibonacci-tree-overlapping-subproblems.png 885w,\n/static/368401b370a0ffa4776f67268829919d/2d849/jarednielsen-big-o-recursion-fibonacci-tree-overlapping-subproblems.png 1180w,\n/static/368401b370a0ffa4776f67268829919d/a987b/jarednielsen-big-o-recursion-fibonacci-tree-overlapping-subproblems.png 1920w\"\n        sizes=\"(max-width: 590px) 100vw, 590px\"\n      />\n    </span>\n  </span>\n  \n  </a>\n    </p>\n<p>How many times do we solve <code>f(0)</code>?</p>\n<p>How many times do we solve <code>f(1)</code>?</p>\n<p>How many times do we solve <code>f(2)</code>?</p>\n<p>How many times do we solve <code>f(3)</code>?</p>\n<p>The answer to all of the above is: too many!</p>\n<h2>Dynamic Programming: Memoization</h2>\n<p>Memoization is the top-down approach to solving a problem with dynamic programming. </p>\n<p>It’s called memoization because we will create a <em>memo</em>, or a “note to self”, for the values returned from solving each problem. </p>\n<p>Then, when we encounter the same problem again, we simply check the memo, and, rather than solving the problem a second (or third or fourth) time, we retrieve the solution from our memo. </p>\n<h3>Top-Down Fibonacci</h3>\n<p>Here’s our Fibonacci sequence, memoized:</p>\n<div class=\"gatsby-highlight\" data-language=\"js\"><pre class=\"language-js\"><code class=\"language-js\"><span class=\"token keyword\">const</span> <span class=\"token function-variable function\">fibDown</span> <span class=\"token operator\">=</span> <span class=\"token punctuation\">(</span><span class=\"token parameter\">n<span class=\"token punctuation\">,</span> memo<span class=\"token operator\">=</span><span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span></span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=></span> <span class=\"token punctuation\">{</span>\n<span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>n <span class=\"token operator\">==</span> <span class=\"token number\">0</span> <span class=\"token operator\">||</span> n <span class=\"token operator\">==</span> <span class=\"token number\">1</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n           <span class=\"token keyword\">return</span> n<span class=\"token punctuation\">;</span>\n     <span class=\"token punctuation\">}</span>\n     <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>memo<span class=\"token punctuation\">[</span>n<span class=\"token punctuation\">]</span> <span class=\"token operator\">==</span> <span class=\"token keyword\">undefined</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n           memo<span class=\"token punctuation\">[</span>n<span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> <span class=\"token function\">fibDown</span><span class=\"token punctuation\">(</span>n <span class=\"token operator\">-</span> <span class=\"token number\">1</span><span class=\"token punctuation\">,</span> memo<span class=\"token punctuation\">)</span> <span class=\"token operator\">+</span> <span class=\"token function\">fibDown</span><span class=\"token punctuation\">(</span>n <span class=\"token operator\">-</span> <span class=\"token number\">2</span><span class=\"token punctuation\">,</span> memo<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n     <span class=\"token punctuation\">}</span>\n     <span class=\"token keyword\">return</span> memo<span class=\"token punctuation\">[</span>n<span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p>Where have we seen this, or something like it, before? </p>\n<p>🤔</p>\n<p>It’s very similar to our naive implementation.</p>\n<p>But!</p>\n<p>We now pass our function a <code>memo</code> argument and initialize it as an array. </p>\n<p>Each time we recursively call <code>fibDown()</code>, we pass it the <code>memo</code> array. </p>\n<p>If the value of <code>memo[n]</code> is undefined, meaning there’s no value stored in that index yet, we assign that value the returned values of <code>fibDown(n - 1, memo) + fibDown(n - 2, memo)</code>.</p>\n<p>What’s the time complexity? </p>\n<p>O(n).</p>\n<p>Why? </p>\n<p>Because we don’t solve the <em>overlapping subproblems</em>.</p>\n<p>This is a big improvement over the naive implementation.</p>\n<p>What’s the space complexity? </p>\n<p>Also O(n).</p>\n<h2>Dynamic Programming: Tabulation</h2>\n<p>With bottom-up, or <em>tabulation</em>, we start with the smallest problems and use the returned values to calculate larger values. </p>\n<p>We can think of it as entering values in a table, or spreadsheet, and then applying a formula to those values.</p>\n<h3>Bottom-Up Fibonacci</h3>\n<p>Here’s our Fibonacci sequence, <em>tabulated</em>:</p>\n<div class=\"gatsby-highlight\" data-language=\"js\"><pre class=\"language-js\"><code class=\"language-js\"><span class=\"token keyword\">const</span> <span class=\"token function-variable function\">fibottomUp</span> <span class=\"token operator\">=</span> <span class=\"token parameter\">n</span> <span class=\"token operator\">=></span> <span class=\"token punctuation\">{</span>\n<span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>n <span class=\"token operator\">===</span> <span class=\"token number\">0</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n           <span class=\"token keyword\">return</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span>\n     <span class=\"token punctuation\">}</span>\n     <span class=\"token keyword\">let</span> x <span class=\"token operator\">=</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span>\n     <span class=\"token keyword\">let</span> y <span class=\"token operator\">=</span> <span class=\"token number\">1</span><span class=\"token punctuation\">;</span>\n     <span class=\"token keyword\">for</span> <span class=\"token punctuation\">(</span><span class=\"token keyword\">let</span> i <span class=\"token operator\">=</span> <span class=\"token number\">2</span><span class=\"token punctuation\">;</span> i <span class=\"token operator\">&lt;</span> n<span class=\"token punctuation\">;</span> i<span class=\"token operator\">++</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n           <span class=\"token keyword\">let</span> tmp <span class=\"token operator\">=</span> x <span class=\"token operator\">+</span> y<span class=\"token punctuation\">;</span>\n           x <span class=\"token operator\">=</span> y<span class=\"token punctuation\">;</span>\n           y <span class=\"token operator\">=</span> tmp<span class=\"token punctuation\">;</span>\n     <span class=\"token punctuation\">}</span>\n     <span class=\"token keyword\">return</span> x <span class=\"token operator\">+</span> y<span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p>Where have we seen this, or something like it, before? </p>\n<p>🤔</p>\n<p>This solution is very similar to a swap algorithm. </p>\n<p>We declare three local variables, <code>x</code>, <code>y</code> and <code>tmp</code> and then juggle the values.</p>\n<p>What is the Big O of <code>fibottomUp()</code>? </p>\n<p>Like memoization above, the time complexity is also O(n).</p>\n<p>Why? </p>\n<p>We are using a <code>for</code> loop to iterate over the value of <code>n</code>.</p>\n<p>But the space complexity is O(1). </p>\n<p>Why? </p>\n<p>No recursion.</p>\n<p>We are only pushing one call to the stack.</p>\n<h2>Dynamic Programming: Memoization and Tabulation</h2>\n<p>Which is better? Memoizaiton or tabulation? </p>\n<p>If we don’t need to solve <em>all</em> the problems and are just looking for the optimal solution, memoization is better. </p>\n<p>If we do need to solve all the problems, that means we are going to make a lot of recursive calls, and tabulation is better.</p>\n<p>The caveat is that memoization is generally more intuitive to implement especially when we don’t know the solution to subproblems, whereas tabulation requires us to know the solutions, or bottom, in advance, in order to build our way up. </p>\n<p>In this tutorial, you learned the fundamentals of the two approaches to dynamic programming: memoization and tabulation. Stay tuned for the next articles in this series: Big O factorial time complexity and NP-complete problems. </p>","frontmatter":{"title":"What is Dynamic Programming? Memoization and Tabulation","date":"March 27, 2020","description":"In this tutorial, you will learn the fundamentals of the two approaches to dynamic programming, memoization and tabulation. Dynamic programming is a fancy name for effeciently solving a big problem by breaking it down into smaller problems and caching those solutions to avoid solving them more than once."}}},"pageContext":{"isCreatedByStatefulCreatePages":false,"slug":"/dynamic-programming-memoization-tabulation/","previous":{"fields":{"slug":"/big-o-recursive-space-complexity/"},"frontmatter":{"title":"Big O Recursive Space Complexity"}},"next":null}}}