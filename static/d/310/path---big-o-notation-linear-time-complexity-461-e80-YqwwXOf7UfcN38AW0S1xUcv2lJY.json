{"data":{"site":{"siteMetadata":{"title":"jarednielsen.com","author":"Jared Nielsen"}},"markdownRemark":{"id":"71628e78-1f00-5ebe-ad39-677f9728ada0","excerpt":"Is there a computer science topic more terrifying than Big O notation? Don’t let the name scare you, Big O notation is not a big deal. It’s very easy to…","html":"<p><img src=\"./jarednielsen-big-o.png\"></p>\n<p>Is there a computer science topic more terrifying than Big O notation? Don’t let the name scare you, Big O notation is not a big deal. It’s very easy to understand and you don’t need to be a math whiz to do so. In this tutorial, you’ll learn the fundamentals of Big O notation, as well as constant and linear time complexity with examples in JavaScript.</p>\n<hr>\n<p>This is the first in a series on Big O notation. If you want to stay in the loop, <a href=\"http://eepurl.com/cP8CMn\">sign up for my weekly newsletter, The Solution</a>.</p>\n<hr>\n<h2>What Problem(s) Does Big O Notation Solve?</h2>\n<ul>\n<li>\n<p>Big O notation helps us answer the question, “Will it scale?” </p>\n</li>\n<li>\n<p>Big O notation also equips us with a shared language for discussing performance with other developers (and mathematicians!).</p>\n</li>\n</ul>\n<h2>What is Big O Notation?</h2>\n<p>Big O is a notation for measuring the performance of an algorithm. Big O notation mathematically describes the complexity of an algorithm in terms of time and space. We don’t measure the <em>speed</em> of an algorithm in seconds (or minutes!). We measure the <em>rate of growth</em> of an algorithm in the number of operations it takes to complete. </p>\n<p>The O is short for “Order of magnitude”. So, if we’re discussing an algorithm with <em>O(n)</em>, we say its order of magnitude, or rate of growth, is <em>n</em>, or linear complexity. </p>\n<p>You will probably read or hear Big O referred to as asymptotic runtime, or <a href=\"https://en.wikipedia.org/wiki/Asymptotic_computational_complexity\">asymptotic computational complexity</a>. This is a fancy way of describing the limits of a function. There is a branch of mathematics, <a href=\"https://en.wikipedia.org/wiki/Order_theory\">order theory</a>, devoted to this topic. For our intents and purposes, <em>order</em>: </p>\n<blockquote>\n<p>… provides a formal framework for describing statements such as “this is less than that” or “this precedes that”.</p>\n</blockquote>\n<p>We use <em>order</em> to evaluate the complexity of our algorithms.</p>\n<h3>Math O’Clock</h3>\n<p>You don’t need to be a math whiz to grok Big O, but there are a few basic concepts we need to cover to set you up for success.</p>\n<p>If you recall from algebra, you worked with functions such as <em>f(x)</em> and <em>g(x)</em>, and even did things like <em>f(g(x))</em>, where <em>f()</em> and <em>g()</em> were equations and <em>x</em> was a numerical value (or another equation!) passed to the functions. </p>\n<p>When we’re programming, we give our “equations” descriptive names (at least I hope you are), such as <code>isAuthenticated</code> and <code>calcuateMedian</code>, but we could also name them <code>f</code> and <code>g</code> (please don’t). </p>\n<p>Let’s say <em>f(x)</em> is equal to <em>3x^2 + 12x - 6</em>.</p>\n<p>We could say that the order of magnitude (rate of growth) of <em>f(x)</em> is <em>O(n^2)</em>. (We’ll see why later.) </p>\n<p>It’s more common to simply say “<em>f(x)</em> is order of n^2”, or “<em>f(x)</em> is Big O of n^2”.</p>\n<p>That’s it! </p>\n<p>Math time over.</p>\n<p>For now.</p>\n<h2>How Does Big O Notation Work?</h2>\n<p>Big O notation measures the <em>worst-case runtime</em>. </p>\n<p>Why?</p>\n<p>Because we don’t know what we don’t know.</p>\n<p>If we’re writing a search algorithm, we won’t always know the query ahead of time. If we’re writing a sorting algorithm, we won’t always know the dataset ahead of time. What if the query is the very last element or what if the dataset is a real mess. We want to know just how poorly our algorithm will perform.</p>\n<p>The worst-case scenario is also known as the “upper bound”. Limits again!</p>\n<p>You’re going to encounter a lot of tables like this: </p>\n<table>\n<thead>\n<tr>\n<th>O</th>\n<th>Run time</th>\n<th></th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>O(1)</td>\n<td>constant</td>\n<td>fast</td>\n</tr>\n<tr>\n<td>O(log n)</td>\n<td>logarithmic</td>\n<td></td>\n</tr>\n<tr>\n<td>O(n)</td>\n<td>linear</td>\n<td></td>\n</tr>\n<tr>\n<td>O(n * log n)</td>\n<td>log linear</td>\n<td></td>\n</tr>\n<tr>\n<td>O(n^2)</td>\n<td>quadratic</td>\n<td></td>\n</tr>\n<tr>\n<td>O(n^3)</td>\n<td>cubic</td>\n<td></td>\n</tr>\n<tr>\n<td>O(2^n)</td>\n<td>exponential</td>\n<td></td>\n</tr>\n<tr>\n<td>O(n!)</td>\n<td>factorial</td>\n<td>slow</td>\n</tr>\n</tbody>\n</table>\n<p>This lists common runtimes from fastest to slowest. </p>\n<p>And you’re definitely going to see this chart:\n\n  <a\n    class=\"gatsby-resp-image-link\"\n    href=\"/static/9c24f10d0295ead7526e32d62fa2eac5/efbcd/jarednielsen-big-o-chart.png\"\n    style=\"display: block\"\n    target=\"_blank\"\n    rel=\"noopener\"\n  >\n  \n  <span\n    class=\"gatsby-resp-image-wrapper\"\n    style=\"position: relative; display: block;  max-width: 590px; margin-left: auto; margin-right: auto;\"\n  >\n    <span\n      class=\"gatsby-resp-image-background-image\"\n      style=\"padding-bottom: 63.15359477124183%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAANCAIAAAAmMtkJAAAACXBIWXMAAAsSAAALEgHS3X78AAACrUlEQVQoz1XRSUwTYRQH8I94Mh7UgyeN8WJijCfjtXZaynYQIXoyeDHRRG/GoMZAHDpMZyEIGBXFgxcTJVIENMFSkO5lWmQ1sQudQikpUFlmulra7zkDhITkHf75kl/ee99DpUIhHw5nAoFcKASRCI5Gc4HARs/7jdddG8ONCf8dYexe99B1i60ZojEsRkAU1QovQUxE2WQySZLRxsZkczNmmCxFrTU1ZRkG2tuB7wCuC/guaHsJXAcoj6wJaA7oNuh+CGO3UGZ9XTaZZKOxyHHA85ISWBaUzLJYDQxmd4tTpMLaoZOEgdvg0YL/moolmt4myT2Toii8hw8VqzIlfHwAjmqYIMCtB6EeZZJJmaYlksQct8MwyghKf3zAeBaYNlW+ewKWeuwlsKccPJVFpy7rqEXxYDBlMm3v4hxN52lawfuM5aH1BXS2wEADeHUg6HbshsTQ1dXvWmlEk3fWonlBSDHMHpYPFuYPzykQ4DHsOAypUd2WhciN67FbB746FJiaUrDU0pI3mZSFgef253z7GKx14Ndir/6frVy2EkoV7HrwGmDCAG4ChDp1502KShmN6VYqTyuX6FD/c7BBGbLo1WZ/EpJVmx4jik51VXBVgrMK7DUwXoXdN9Q7/6WMm+TzNMngNhY+3S85KvIujTyil36UZ0crSrZqcNSobEIPfg3MX4GFixA/A1vnVbzZyqw9I0s9T7HlZt6uV0DBZlA6w4wGQpchdgGSZ0E+BeljUDwCgADKMEZb0gkkJ9YmH90NvjLEhy/FbOcSvtOJuZPxwNHFSJm4giKr6E8CzcbRdAz9WkKCiLwiGp0vGxTQN/9xlMvkAlNWcaE/HOlbWPwSWOwNxT+HVnpDK/22yTdfraxr7sPv2MB0tH922TyzbJ5eNvuiZlewzycO/QeV1h5qGVp6JgAAAABJRU5ErkJggg=='); background-size: cover; display: block;\"\n    >\n      <img\n        class=\"gatsby-resp-image-image\"\n        style=\"width: 100%; height: 100%; margin: 0; vertical-align: middle; position: absolute; top: 0; left: 0; box-shadow: inset 0px 0px 0px 400px white;\"\n        alt=\"jarednielsen big o chart\"\n        title=\"\"\n        src=\"/static/9c24f10d0295ead7526e32d62fa2eac5/fb8a0/jarednielsen-big-o-chart.png\"\n        srcset=\"/static/9c24f10d0295ead7526e32d62fa2eac5/1a291/jarednielsen-big-o-chart.png 148w,\n/static/9c24f10d0295ead7526e32d62fa2eac5/2bc4a/jarednielsen-big-o-chart.png 295w,\n/static/9c24f10d0295ead7526e32d62fa2eac5/fb8a0/jarednielsen-big-o-chart.png 590w,\n/static/9c24f10d0295ead7526e32d62fa2eac5/526de/jarednielsen-big-o-chart.png 885w,\n/static/9c24f10d0295ead7526e32d62fa2eac5/fa2eb/jarednielsen-big-o-chart.png 1180w,\n/static/9c24f10d0295ead7526e32d62fa2eac5/08f6a/jarednielsen-big-o-chart.png 1770w,\n/static/9c24f10d0295ead7526e32d62fa2eac5/efbcd/jarednielsen-big-o-chart.png 2448w\"\n        sizes=\"(max-width: 590px) 100vw, 590px\"\n      />\n    </span>\n  </span>\n  \n  </a>\n    </p>\n<p>We’ll return to both as we proceed. </p>\n<p>Before we get into any code, let’s get hands-on to get a feel (pun intended) for Big O. We’ll use an example from <a href=\"https://amzn.to/376TGy9\">Grokking Algorithms</a>. </p>\n<p>Let’s say I give you a square piece of paper and ask you to divide it into sixteen squares. How would you approach this problem? </p>\n<p>You could take the brute force approach and draw sixteen individual squares. If you take this approach, how many steps, or computations, will you perform? </p>\n<p>Sixteen.</p>\n<p>Is there an approach that requires fewer steps? Of course!</p>\n<p>Fold the paper in half. Then in half again. Four squares! </p>\n<p>Now fold it in half two more times. </p>\n<p>When you unfold it, the paper will be divided into sixteen squares. </p>\n<p>How many steps, or computations, were required?</p>\n<p>Four. </p>\n<p>In Big O notation, our first approach, brute force, is O(n), or linear time. Creating sixteen squares requires sixteen operations. But our second, refactored and optimized, approach is O(log n), or logarithmic time (the inverse of exponentiation). Creating sixteen squares requires only four steps. </p>\n<p>We’ll look at O(log n) later. Let’s begin with O(1), which will help us understand O(n).</p>\n<h3>O(1): Constant Time</h3>\n<p>Say you’re working with an API that returns a users full name in an array, like so: </p>\n<div class=\"gatsby-highlight\" data-language=\"js\"><pre class=\"language-js\"><code class=\"language-js\"><span class=\"token punctuation\">[</span>“Jared”<span class=\"token punctuation\">,</span> “Nielsen”<span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span></code></pre></div>\n<p>Your task is to get the users first name. Easy, in JavaScript:</p>\n<div class=\"gatsby-highlight\" data-language=\"js\"><pre class=\"language-js\"><code class=\"language-js\"><span class=\"token keyword\">const</span> <span class=\"token function-variable function\">getFirstName</span> <span class=\"token operator\">=</span> data <span class=\"token operator\">=></span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">return</span> data<span class=\"token punctuation\">[</span><span class=\"token number\">0</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p>No matter how many times you run your ‘algorithm’, it only needs to perform one operation to return the desired value. That’s O(1), or constant time.</p>\n<p>Here’s another JavaScript example: </p>\n<div class=\"gatsby-highlight\" data-language=\"js\"><pre class=\"language-js\"><code class=\"language-js\"><span class=\"token keyword\">const</span> <span class=\"token function-variable function\">isEven</span> <span class=\"token operator\">=</span> num <span class=\"token operator\">=></span> num <span class=\"token operator\">%</span> <span class=\"token number\">2</span> <span class=\"token operator\">===</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span></code></pre></div>\n<p>Our algorithm checks whether or not a number is even or odd and will return true or false accordingly. It only needs to perform one operation. Again, O(1). </p>\n<p>Another example. Say you are checking your application state to determine whether or not you need to style an alert element with a specific color. You could do so with a series of conditional statements:</p>\n<div class=\"gatsby-highlight\" data-language=\"js\"><pre class=\"language-js\"><code class=\"language-js\"><span class=\"token keyword\">const</span> <span class=\"token function-variable function\">alertColor</span> <span class=\"token operator\">=</span> state <span class=\"token operator\">=></span> <span class=\"token punctuation\">{</span>\n   <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>state <span class=\"token operator\">===</span> <span class=\"token string\">'danger'</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n       <span class=\"token keyword\">return</span> <span class=\"token string\">'crimson'</span><span class=\"token punctuation\">;</span>\n   <span class=\"token punctuation\">}</span> <span class=\"token keyword\">else</span> <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>state <span class=\"token operator\">===</span> <span class=\"token string\">'warning'</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n       <span class=\"token keyword\">return</span> <span class=\"token string\">'orange'</span><span class=\"token punctuation\">;</span>\n   <span class=\"token punctuation\">}</span> <span class=\"token keyword\">else</span> <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>state <span class=\"token operator\">===</span> <span class=\"token string\">'success'</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n       <span class=\"token keyword\">return</span> <span class=\"token string\">'chartreuse'</span><span class=\"token punctuation\">;</span>\n   <span class=\"token punctuation\">}</span> <span class=\"token keyword\">else</span> <span class=\"token punctuation\">{</span>\n       <span class=\"token keyword\">return</span> <span class=\"token string\">'cornflowerblue'</span><span class=\"token punctuation\">;</span>\n   <span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p>What is our best-case scenario for this algorithm? If <code>state</code> is equal to <code>danger</code>, we will only perform one operation and return. That would be O(1). What if <code>state</code> is not equal to <code>danger</code>? Then we perform multiple operations and the order of <code>alertColor()</code> is <em>n</em>. </p>\n<p>Why? We’ll see in a moment. </p>\n<p>If you find yourself writing a lot of conditional statements, you may want to consider implementing a lookup table (LUT) using a JavaScript object. </p>\n<div class=\"gatsby-highlight\" data-language=\"js\"><pre class=\"language-js\"><code class=\"language-js\"><span class=\"token keyword\">const</span> alertTable <span class=\"token operator\">=</span> <span class=\"token punctuation\">{</span>\n   danger<span class=\"token punctuation\">:</span> <span class=\"token string\">'crimson'</span><span class=\"token punctuation\">,</span>\n   warning<span class=\"token punctuation\">:</span> <span class=\"token string\">'orange'</span><span class=\"token punctuation\">,</span>\n   success<span class=\"token punctuation\">:</span> <span class=\"token string\">'chartreuse'</span><span class=\"token punctuation\">,</span>\n<span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span>\n \n<span class=\"token keyword\">const</span> <span class=\"token function-variable function\">alertColor</span> <span class=\"token operator\">=</span> state <span class=\"token operator\">=></span> alertTable<span class=\"token punctuation\">[</span>state<span class=\"token punctuation\">]</span> <span class=\"token operator\">||</span> <span class=\"token string\">'cornflowerblue'</span><span class=\"token punctuation\">;</span></code></pre></div>\n<p>Our LUT is O(1). It only performs one operation, so its time complexity is constant regardless of the size of the lookup table. </p>\n<h3>O(n): Linear Time</h3>\n<p>If O(1) performs only one computation regardless of the size of the input, what is O(n)?</p>\n<p>For <em>n</em> inputs, our algorithm will perform <em>n</em> outputs. This is linear time complexity. </p>\n<p>Why? </p>\n<p>If we were to chart this on a graph, it would be a straight line.</p>\n<p>What if we calculated our operations for this algorithm and it was actually something like: </p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">2n + 5</code></pre></div>\n<p>That’s still just O(n). </p>\n<p>With Big O, we drop the constants and the non-dominant terms. They don’t provide any meaningful additional information. O(n) and O(2n +5) are both linear. If you charted <code>2n + 5</code>, it would still be a straight line. That’s what we really want to know. </p>\n<p>But what if our algorithm, say a search function, returns its parameter after one operation? Would that be O(1)? </p>\n<p>No. It’s still O(n). </p>\n<p>Why? </p>\n<p>Remember, with Big O, we measure the <em>worst case scenario</em>. Because we don’t know what we don’t know, our default assumption for any algorithm is its worst-case scenario. In a worst case scenario, an O(n) algorithm needs to perform its specified operation on every value in the input. When making our Big O calculation, we want to know just how poorly an algorithm is going to perform. </p>\n<p>Say, for example, we have an array of animals: </p>\n<div class=\"gatsby-highlight\" data-language=\"js\"><pre class=\"language-js\"><code class=\"language-js\"><span class=\"token keyword\">const</span> animals <span class=\"token operator\">=</span> <span class=\"token punctuation\">[</span>“ocelot”<span class=\"token punctuation\">,</span> “octopus”<span class=\"token punctuation\">,</span> “opossum”<span class=\"token punctuation\">,</span> “orangutan”<span class=\"token punctuation\">,</span> “orca”<span class=\"token punctuation\">,</span> “oriole”<span class=\"token punctuation\">,</span> “oryx”<span class=\"token punctuation\">,</span> “osprey”<span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span></code></pre></div>\n<p>And let’s say our task is to find the location of a specific animal in the array based on user input:</p>\n<div class=\"gatsby-highlight\" data-language=\"js\"><pre class=\"language-js\"><code class=\"language-js\"><span class=\"token keyword\">for</span> <span class=\"token punctuation\">(</span><span class=\"token keyword\">let</span> i <span class=\"token operator\">=</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span> i <span class=\"token operator\">&lt;</span> animals<span class=\"token punctuation\">.</span>length<span class=\"token punctuation\">;</span> i<span class=\"token operator\">++</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>animals<span class=\"token punctuation\">[</span>i<span class=\"token punctuation\">]</span> <span class=\"token operator\">===</span> userInput<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        <span class=\"token keyword\">return</span> <span class=\"token template-string\"><span class=\"token string\">`Found </span><span class=\"token interpolation\"><span class=\"token interpolation-punctuation punctuation\">${</span>userInput<span class=\"token interpolation-punctuation punctuation\">}</span></span><span class=\"token string\"> at </span><span class=\"token interpolation\"><span class=\"token interpolation-punctuation punctuation\">${</span>i<span class=\"token interpolation-punctuation punctuation\">}</span></span><span class=\"token string\">`</span></span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span></code></pre></div>\n<p>If our user searches for “ocelot”, how many computations are performed? </p>\n<p>One. It’s the first item in our array, so our program will return. </p>\n<p>But, if our user searches for “osprey”, how many computations are performed? </p>\n<p>Eight. That’s our worst case scenario. For eight inputs, our algorithm will perform eight operations.</p>\n<p>What if our array contained 100 animals? </p>\n<p>The worst-case scenario would be 100 operations. </p>\n<p>What about 1,000?</p>\n<p>10,000?</p>\n<p>100,000?</p>\n<p>1,000,000?</p>\n<p>All O(n).</p>\n<p>You can see how linear complexity is fine for small datasets, but becomes a concern when the size of the input increases. </p>\n<p>Does O(n) scale? </p>\n<p>We can do better <em>and</em> worse. </p>\n<h2>What is Big O Notation? Linear &#x26; Constant Time Complexity in JavaScript</h2>\n<p>Big O notation is not a big deal. It’s very easy to understand and you don’t need to be a math whiz to do so. In this tutorial, you learned the fundamentals of Big O notation, as well as constant and linear time complexity with examples in JavaScript.</p>\n<p>Stay tuned for part two of this series on Big O notation where we’ll look at O(n^2), or quadratic time complexity.</p>\n<p><em>Note: Amazon links are affiliate.</em></p>","frontmatter":{"title":"What is Big O Notation? Constant & Linear Time Complexity in JavaScript","date":"January 20, 2020","description":"Big O notation is not a big deal. Learn the fundamentals of Big O notation, as well as constant and linear time complexity with examples in JavaScript."}}},"pageContext":{"slug":"/big-o-notation-linear-time-complexity/","previous":{"fields":{"slug":"/programming-problem-solving/"},"frontmatter":{"title":"Programming is Problem Solving"}},"next":null}}